

################ FILE: ./atomlab_pro_modules/orbital_engine.py ################


# orbital_engine.py
import numpy as np
from scipy.special import sph_harm, genlaguerre

# Hydrogenic radial wavefunction (unnormalized) R_{n,l}(r) in atomic units (a0=1)
# For visualization we'll compute probability density |psi|^2

def radial_part(n, l, r):
    # n: principal, l: orbital
    rho = 2.0 * r / n
    # Associated Laguerre L_{n-l-1}^{2l+1}(rho)
    k = n - l - 1
    if k < 0:
        return np.zeros_like(r)
    L = genlaguerre(k, 2*l+1)(rho)
    prefactor = (2.0/n)**3 * math.factorial(k) / (2*n*math.factorial(n + l)) if (n+l)>=0 else (2.0/n)**3
    R = (rho**l) * np.exp(-rho/2.0) * L
    return R

def hydrogen_wavefunction(n, l, m, r, theta, phi):
    # radial * angular
    R = radial_part(n,l,r)
    Y = sph_harm(m, l, phi, theta)
    psi = R * Y
    return psi



################ FILE: ./atomlab_pro_modules/periodic_table.py ################


# periodic_table.py
# Contains full periodic table (Z, symbol, name, period, group, IE, EN, covalent radius)
PERIODIC = {
1: {'symbol':'H','name':'Hydrogen','period':1,'group':1,'IE':13.5984,'EN':2.20,'rcov':31},
2: {'symbol':'He','name':'Helium','period':1,'group':18,'IE':24.5874,'EN':None,'rcov':28},
3: {'symbol':'Li','name':'Lithium','period':2,'group':1,'IE':5.3917,'EN':0.98,'rcov':128},
4: {'symbol':'Be','name':'Beryllium','period':2,'group':2,'IE':9.3227,'EN':1.57,'rcov':96},
5: {'symbol':'B','name':'Boron','period':2,'group':13,'IE':8.298,'EN':2.04,'rcov':84},
6: {'symbol':'C','name':'Carbon','period':2,'group':14,'IE':11.2603,'EN':2.55,'rcov':76},
7: {'symbol':'N','name':'Nitrogen','period':2,'group':15,'IE':14.5341,'EN':3.04,'rcov':71},
8: {'symbol':'O','name':'Oxygen','period':2,'group':16,'IE':13.6181,'EN':3.44,'rcov':66},
9: {'symbol':'F','name':'Fluorine','period':2,'group':17,'IE':17.4228,'EN':3.98,'rcov':57},
10:{'symbol':'Ne','name':'Neon','period':2,'group':18,'IE':21.5645,'EN':None,'rcov':58},
11:{'symbol':'Na','name':'Sodium','period':3,'group':1,'IE':5.1391,'EN':0.93,'rcov':166},
12:{'symbol':'Mg','name':'Magnesium','period':3,'group':2,'IE':7.6462,'EN':1.31,'rcov':141},
13:{'symbol':'Al','name':'Aluminium','period':3,'group':13,'IE':5.9858,'EN':1.61,'rcov':121},
14:{'symbol':'Si','name':'Silicon','period':3,'group':14,'IE':8.1517,'EN':1.90,'rcov':111},
15:{'symbol':'P','name':'Phosphorus','period':3,'group':15,'IE':10.4867,'EN':2.19,'rcov':107},
16:{'symbol':'S','name':'Sulfur','period':3,'group':16,'IE':10.3600,'EN':2.58,'rcov':105},
17:{'symbol':'Cl','name':'Chlorine','period':3,'group':17,'IE':12.9676,'EN':3.16,'rcov':102},
18:{'symbol':'Ar','name':'Argon','period':3,'group':18,'IE':15.7596,'EN':None,'rcov':106},
# ... fill up to 118 with commonly available values (truncated for brevity in this template)
}

def get_element(Z):
    return PERIODIC.get(Z, None)


################ FILE: ./atomlab_pro_modules/ui.py ################


# ui.py - helper UI functions for Streamlit rendering
import streamlit as st
import plotly.graph_objects as go
import numpy as np

def plot_bohr_svg(n_list, angle=0.0, highlight=None, size=500):
    # returns html svg string
    base = 40
    cx = cy = size//2
    svg = [f"<svg width='{size}' height='{size}' viewBox='0 0 {size} {size}' xmlns='http://www.w3.org/2000/svg'>"]
    svg.append(f"<rect width='100%' height='100%' fill='#07070a' />")
    svg.append(f"<circle cx='{cx}' cy='{cy}' r='8' fill='#ff6666' />")
    for n in n_list:
        r = base * n
        svg.append(f"<circle cx='{cx}' cy='{cy}' r='{r}' stroke='#4c8cff' fill='none' stroke-width='2' opacity='0.6' />")
    if highlight is not None:
        r = base * highlight
        ex = cx + r * math.cos(angle)
        ey = cy + r * math.sin(angle)
        svg.append(f"<circle cx='{ex}' cy='{ey}' r='6' fill='#00ffcc' />")
    svg.append("</svg>")
    return '\n'.join(svg)

def plot_orbital_plotly(X,Y,Z,Values, isosurface=0.02):
    fig = go.Figure(data=go.Isosurface(x=X.flatten(), y=Y.flatten(), z=Z.flatten(), value=Values.flatten(), isomin=Values.max()*isosurface, isomax=Values.max(), surface_count=4))
    fig.update_layout(scene=dict(xaxis_visible=False,yaxis_visible=False,zaxis_visible=False), margin=dict(t=0,l=0,r=0,b=0))
    return fig


################ FILE: ./atomlab_pro_modules/bohr_model.py ################


# bohr_model.py
import math
from math import cos, sin, pi

def wavelength_ev_to_nm(E_eV):
    # h (eV*s) * c (m/s) / E (eV) -> meters -> nm
    h_eV_s = 4.135667696e-15
    c = 299792458.0
    if E_eV <= 0:
        return None
    lam_m = (h_eV_s * c) / E_eV
    return lam_m * 1e9

# Map visible wavelength (380..750 nm) to approximate RGB
def wavelength_to_rgb(wavelength_nm):
    if wavelength_nm is None:
        return (255,255,255)
    w = float(wavelength_nm)
    gamma = 0.8
    R=G=B=0.0
    if 380 <= w <= 440:
        R = -(w - 440) / (440 - 380)
        G = 0.0
        B = 1.0
    elif 440 <= w <= 490:
        R = 0.0
        G = (w - 440) / (490 - 440)
        B = 1.0
    elif 490 <= w <= 510:
        R = 0.0
        G = 1.0
        B = -(w - 510) / (510 - 490)
    elif 510 <= w <= 580:
        R = (w - 510) / (580 - 510)
        G = 1.0
        B = 0.0
    elif 580 <= w <= 645:
        R = 1.0
        G = -(w - 645) / (645 - 580)
        B = 0.0
    elif 645 <= w <= 750:
        R = 1.0
        G = 0.0
        B = 0.0
    else:
        R=G=B=0.0
    # Intensity correction
    if 380 <= w <= 420:
        factor = 0.3 + 0.7*(w - 380)/(420-380)
    elif 420 <= w <= 700:
        factor = 1.0
    elif 700 <= w <= 750:
        factor = 0.3 + 0.7*(750 - w)/(750-700)
    else:
        factor = 0.0
    def adjust(c):
        if c==0.0:
            return 0
        return int(round((c*factor)**gamma * 255))
    return (adjust(R), adjust(G), adjust(B))


################ FILE: ./main.py ################

import streamlit as st
import sys
import os

# --- –ú–ê–ì–Ü–Ø –î–õ–Ø –Ü–ú–ü–û–†–¢–Ü–í (–í–∏–ø—Ä–∞–≤–ª—è—î Pylance/Module errors) ---
# –î–æ–¥–∞—î–º–æ –ø–æ—Ç–æ—á–Ω—É –ø–∞–ø–∫—É –¥–æ —à–ª—è—Ö—ñ–≤ –ø–æ—à—É–∫—É Python
current_dir = os.path.dirname(os.path.abspath(__file__))
if current_dir not in sys.path:
    sys.path.append(current_dir)

# –¢–µ–ø–µ—Ä —ñ–º–ø–æ—Ä—Ç–∏ —Ç–æ—á–Ω–æ –∑–∞–ø—Ä–∞—Ü—é—é—Ç—å
try:
    import matplotlib
    matplotlib.use('Agg') 
    import matplotlib.pyplot as plt
    from scipy import constants

    # –Ü–º–ø–æ—Ä—Ç –∑ –≤–∞—à–∏—Ö –º–æ–¥—É–ª—ñ–≤
    from modules.utils import M_E, EV
    from modules.wells import (
        run_infinite_well_sim,
        run_finite_well_sim,
        get_wavefunction_inf,
        get_wavefunction_finite
    )
    from modules.oscillator import run_oscillator_sim
    from modules.barriers import run_barrier_sim
    from modules.wavepacket import run_wave_packet_simulation

except ImportError as e:
    st.error(f"üö® –ü–æ–º–∏–ª–∫–∞ —ñ–º–ø–æ—Ä—Ç—É! –ü–µ—Ä–µ–≤—ñ—Ä—Ç–µ —Å—Ç—Ä—É–∫—Ç—É—Ä—É –ø–∞–ø–æ–∫.\n–î–µ—Ç–∞–ª—ñ: {e}")
    st.stop()

# --- –ù–ê–õ–ê–®–¢–£–í–ê–ù–ù–Ø –°–¢–û–†–Ü–ù–ö–ò ---
st.set_page_config(layout="wide", page_title="Quantum Solver Modular", page_icon="‚öõÔ∏è")
plt.style.use('default') 

def main():
    st.sidebar.title("üéõ –ü–∞–Ω–µ–ª—å –ö–µ—Ä—É–≤–∞–Ω–Ω—è")
    
    # 1. –í–∏–±—ñ—Ä —Å–∏—Å—Ç–µ–º–∏
    sys_type = st.sidebar.selectbox("–û–±–µ—Ä—ñ—Ç—å –∑–∞–¥–∞—á—É:", 
        ["–ü–æ—Ç–µ–Ω—Ü—ñ–∞–ª—å–Ω–∞ –Ø–º–∞", "–ü–æ—Ç–µ–Ω—Ü—ñ–∞–ª—å–Ω–∏–π –ë–∞—Ä'—î—Ä", "–ì–∞—Ä–º–æ–Ω—ñ—á–Ω–∏–π –û—Å—Ü–∏–ª—è—Ç–æ—Ä", "üåä –•–≤–∏–ª—å–æ–≤–∏–π –ü–∞–∫–µ—Ç"])
    
    sub_type = None
    if sys_type == "–ü–æ—Ç–µ–Ω—Ü—ñ–∞–ª—å–Ω–∞ –Ø–º–∞":
        sub_type = st.sidebar.radio("–¢–∏–ø:", ["–ù–µ—Å–∫—ñ–Ω—á–µ–Ω–Ω—ñ —Å—Ç—ñ–Ω–∫–∏", "–ö—ñ–Ω—Ü–µ–≤—ñ —Å—Ç—ñ–Ω–∫–∏"])
    elif sys_type == "–ü–æ—Ç–µ–Ω—Ü—ñ–∞–ª—å–Ω–∏–π –ë–∞—Ä'—î—Ä":
        sub_type = st.sidebar.radio("–¢–∏–ø:", ["–°—Ö–æ–¥–∏–Ω–∫–∞", "–ü—Ä—è–º–æ–∫—É—Ç–Ω–∏–π –±–∞—Ä'—î—Ä"])

    st.sidebar.markdown("---")
    
    # 2. –ü–∞—Ä–∞–º–µ—Ç—Ä–∏
    st.sidebar.header("–ü–∞—Ä–∞–º–µ—Ç—Ä–∏")
    params = {}
    
    # –í–∏–±—ñ—Ä —á–∞—Å—Ç–∏–Ω–∫–∏
    p_name = st.sidebar.selectbox("–ß–∞—Å—Ç–∏–Ω–∫–∞:", ["–ï–ª–µ–∫—Ç—Ä–æ–Ω", "–ü—Ä–æ—Ç–æ–Ω", "–ú—é–æ–Ω"])
    mass_map = {"–ï–ª–µ–∫—Ç—Ä–æ–Ω": M_E, "–ü—Ä–æ—Ç–æ–Ω": constants.m_p, "–ú—é–æ–Ω": M_E * 207}
    params['m'] = mass_map[p_name]
    st.sidebar.caption(f"m = {params['m']:.2e} –∫–≥")

    # –î–∏–Ω–∞–º—ñ—á–Ω—ñ –ø–æ–ª—è
    if sys_type != "–ì–∞—Ä–º–æ–Ω—ñ—á–Ω–∏–π –û—Å—Ü–∏–ª—è—Ç–æ—Ä":
        params['L'] = st.sidebar.number_input("–®–∏—Ä–∏–Ω–∞ L (–º)", value=1e-9, format="%.2e")
    
    if sys_type in ["–ü–æ—Ç–µ–Ω—Ü—ñ–∞–ª—å–Ω–∏–π –ë–∞—Ä'—î—Ä", "üåä –•–≤–∏–ª—å–æ–≤–∏–π –ü–∞–∫–µ—Ç"] or \
       (sys_type == "–ü–æ—Ç–µ–Ω—Ü—ñ–∞–ª—å–Ω–∞ –Ø–º–∞" and sub_type == "–ö—ñ–Ω—Ü–µ–≤—ñ —Å—Ç—ñ–Ω–∫–∏"):
        params['U0'] = st.sidebar.number_input("–ü–æ—Ç–µ–Ω—Ü—ñ–∞–ª U‚ÇÄ (–µ–í)", value=10.0, step=0.1) * EV
        
    if sys_type in ["–ü–æ—Ç–µ–Ω—Ü—ñ–∞–ª—å–Ω–∏–π –ë–∞—Ä'—î—Ä", "üåä –•–≤–∏–ª—å–æ–≤–∏–π –ü–∞–∫–µ—Ç"]:
        params['E'] = st.sidebar.number_input("–ï–Ω–µ—Ä–≥—ñ—è E (–µ–í)", value=5.0, step=0.1) * EV
        
    if sys_type == "–ì–∞—Ä–º–æ–Ω—ñ—á–Ω–∏–π –û—Å—Ü–∏–ª—è—Ç–æ—Ä":
        params['omega'] = st.sidebar.number_input("–ß–∞—Å—Ç–æ—Ç–∞ œâ (—Ä–∞–¥/—Å)", value=5e15, format="%.2e", step=0.1e15)

    st.sidebar.markdown("---")
    
    # –ö–Ω–æ–ø–∫–∞ –∑–∞–ø—É—Å–∫—É
    if st.sidebar.button("üöÄ –†–û–ó–†–ê–•–£–í–ê–¢–ò", type="primary"):
        st.session_state['run_calc'] = True

    # 3. –ó–∞–ø—É—Å–∫ –ª–æ–≥—ñ–∫–∏ –∑ –º–æ–¥—É–ª—ñ–≤
    if st.session_state.get('run_calc'):
        st.title(f"–†–µ–∑—É–ª—å—Ç–∞—Ç–∏: {sys_type}")
        
        if sys_type == "–ü–æ—Ç–µ–Ω—Ü—ñ–∞–ª—å–Ω–∞ –Ø–º–∞":
            if sub_type == "–ù–µ—Å–∫—ñ–Ω—á–µ–Ω–Ω—ñ —Å—Ç—ñ–Ω–∫–∏":
                run_infinite_well_sim(params)
            elif sub_type == "–ö—ñ–Ω—Ü–µ–≤—ñ —Å—Ç—ñ–Ω–∫–∏":
                run_finite_well_sim(params)
                
        elif sys_type == "–ì–∞—Ä–º–æ–Ω—ñ—á–Ω–∏–π –û—Å—Ü–∏–ª—è—Ç–æ—Ä":
            run_oscillator_sim(params)
            
        elif sys_type == "–ü–æ—Ç–µ–Ω—Ü—ñ–∞–ª—å–Ω–∏–π –ë–∞—Ä'—î—Ä":
            run_barrier_sim(params, sub_type)
            
        elif sys_type == "üåä –•–≤–∏–ª—å–æ–≤–∏–π –ü–∞–∫–µ—Ç":
            run_wave_packet_simulation()

            import sys, os
current_dir = os.path.dirname(os.path.abspath(__file__))
modules_dir = os.path.join(current_dir, "modules")

if modules_dir not in sys.path:
    sys.path.append(modules_dir)

if __name__ == "__main__":
    main()

################ FILE: ./modules/barriers.py ################

# modules/barriers.py
# –ú–æ–¥—É–ª—å –¥–ª—è —Å–∏–º—É–ª—è—Ü—ñ—ó –∫–≤–∞–Ω—Ç–æ–≤–æ–≥–æ –±–∞—Ä'—î—Ä–∞
# –ï–∫—Å–ø–æ—Ä—Ç—É—î —Ñ—É–Ω–∫—Ü—ñ—é run_barrier_sim()
# ------------------------------------------------------------------------------

import streamlit as st
import numpy as np
import matplotlib
matplotlib.use('Agg')
import matplotlib.pyplot as plt
import math
from scipy import constants
from scipy import linalg

# -------------------------------------------------------------------------
# 1. –ö–û–ù–°–¢–ê–ù–¢–ò
# -------------------------------------------------------------------------
HBAR = constants.hbar
M_E = constants.m_e
M_P = constants.m_p
EV = constants.electron_volt

# –ü—Ä–∏–º—ñ—Ç–∫–∞: st.set_page_config –≤–∏–¥–∞–ª–µ–Ω–æ, –æ—Å–∫—ñ–ª—å–∫–∏ —Ü–µ–π —Ñ–∞–π–ª —ñ–º–ø–æ—Ä—Ç—É—î—Ç—å—Å—è —è–∫ –º–æ–¥—É–ª—å.
# –ö–æ–Ω—Ñ—ñ–≥—É—Ä–∞—Ü—ñ—è —Å—Ç–æ—Ä—ñ–Ω–∫–∏ –º–∞—î –±—É—Ç–∏ —É –≤–∞—à–æ–º—É –≥–æ–ª–æ–≤–Ω–æ–º—É —Ñ–∞–π–ª—ñ.

plt.style.use('default')

# -------------------------------------------------------------------------
# 2. –ú–ê–¢–ï–ú–ê–¢–ò–ß–ù–ï –Ø–î–†–û
# -------------------------------------------------------------------------

def safe_sqrt_complex(x):
    """–ë–µ–∑–ø–µ—á–Ω–∏–π –∫–æ—Ä—ñ–Ω—å –¥–ª—è —Å–∫–∞–ª—è—Ä–∞ —á–∏ –º–∞—Å–∏–≤—É (–ø–æ–≤–µ—Ä—Ç–∞—î –∫–æ–º–ø–ª–µ–∫—Å–Ω—ñ –∑–Ω–∞—á–µ–Ω–Ω—è –ø—Ä–∏ –ø–æ—Ç—Ä–µ–±—ñ)."""
    return np.sqrt(x + 0j)

def get_k(E, m, U=0.0):
    """
    –†–æ–∑—Ä–∞—Ö–æ–≤—É—î —Ö–≤–∏–ª—å–æ–≤–∏–π –≤–µ–∫—Ç–æ—Ä k (–º–æ–∂–µ –±—É—Ç–∏ –∫–æ–º–ø–ª–µ–∫—Å–Ω–∏–º).
    –ü–æ–≤–µ—Ä—Ç–∞—î –∫–æ–º–ø–ª–µ–∫—Å–Ω–µ —á–∏—Å–ª–æ.
    –§–æ—Ä–º—É–ª–∞: k = sqrt(2 m (E - U)) / hbar
    """
    val = 2.0 * m * (E - U)
    return safe_sqrt_complex(val) / HBAR

class BarrierSolver:
    """–ö–ª–∞—Å –¥–ª—è —Ä–æ–∑—Ä–∞—Ö—É–Ω–∫—É —Ö–≤–∏–ª—å–æ–≤–æ—ó —Ñ—É–Ω–∫—Ü—ñ—ó –¥–ª—è —Å—Ö–æ–¥–∏–Ω–∫–∏ —Ç–∞ –ø—Ä—è–º–æ–∫—É—Ç–Ω–æ–≥–æ –±–∞—Ä'—î—Ä–∞."""
    def __init__(self, m):
        self.m = float(m)

    def solve_step(self, E, U0, x):
        """
        –†–æ–∑–≤'—è–∑–æ–∫ –¥–ª—è –ø–æ—Ç–µ–Ω—Ü—ñ–∞–ª—å–Ω–æ—ó —Å—Ö–æ–¥–∏–Ω–∫–∏ –≤ x=0: U(x<0)=0, U(x>=0)=U0
        –ü–æ–≤–µ—Ä—Ç–∞—î: psi_real (–º–∞—Å–∏–≤), prob_density (–º–∞—Å–∏–≤), T (float), R (float)
        """
        x = np.array(x, dtype=float)
        k1 = get_k(E, self.m, 0.0)
        k1 = complex(k1)

        if E > U0:
            k2 = get_k(E, self.m, U0)
            k2 = complex(k2)
            # –ê–º–ø–ª—ñ—Ç—É–¥–∏ –≤—ñ–¥–±–∏—Ç—Ç—è —ñ –ø—Ä–æ–ø—É—Å–∫–∞–Ω–Ω—è
            R_amp = (k1 - k2) / (k1 + k2)
            T_amp = 2.0 * k1 / (k1 + k2)

            psi = np.zeros_like(x, dtype=complex)
            left_mask = x < 0
            right_mask = x >= 0

            psi[left_mask] = np.exp(1j * k1 * x[left_mask]) + R_amp * np.exp(-1j * k1 * x[left_mask])
            psi[right_mask] = T_amp * np.exp(1j * k2 * x[right_mask])

            k1_r = k1.real if abs(k1.real) > 1e-18 else 1e-18
            k2_r = k2.real if abs(k2.real) > 1e-18 else 1e-18
            T = (k2_r / k1_r) * (abs(T_amp)**2)
            R = abs(R_amp)**2
            return np.real(psi), np.abs(psi)**2, T, R
        else:
            # E < U0
            k2 = get_k(E, self.m, U0)
            kappa = abs(complex(k2).imag)
            psi = np.zeros_like(x, dtype=complex)
            left_mask = x < 0
            right_mask = x >= 0
            
            psi[left_mask] = np.exp(1j * k1 * x[left_mask]) + np.exp(-1j * k1 * x[left_mask])
            psi[right_mask] = np.exp(-kappa * x[right_mask])
            
            # T = 0, R = 1
            return np.real(psi), np.abs(psi)**2, 0.0, 1.0

    def solve_rectangular(self, E, U0, L, x):
        """
        –†–æ–∑–≤'—è–∑–æ–∫ –¥–ª—è –ø—Ä—è–º–æ–∫—É—Ç–Ω–æ–≥–æ –±–∞—Ä'—î—Ä–∞ —à–∏—Ä–∏–Ω–æ—é L.
        –ü–æ–≤–µ—Ä—Ç–∞—î psi_real, prob_density, T, R
        """
        x = np.array(x, dtype=float)
        k1 = complex(get_k(E, self.m, 0.0))
        k2_complex = complex(get_k(E, self.m, U0))

        T = 0.0
        R = 1.0
        try:
            if E > U0:
                k2r = k2_complex.real
                denom = 1.0 + (U0**2 * (np.sin(k2r * L)**2)) / (4.0 * E * (E - U0))
                if denom == 0:
                    T = 0.0
                else:
                    T = 1.0 / denom
            else:
                kappa = abs(k2_complex.imag)
                if kappa * L > 100.0:
                    T = 0.0
                else:
                    denom = 1.0 + (U0**2 * (np.sinh(kappa * L)**2)) / (4.0 * E * (U0 - E))
                    T = 1.0 / denom
            R = max(0.0, 1.0 - T)
        except Exception:
            T = 0.0
            R = 1.0

        psi = np.zeros_like(x, dtype=complex)
        left_mask = x < 0
        mid_mask = (x >= 0) & (x <= L)
        right_mask = x > L

        try:
            k1c = k1
            k2c = k2_complex
            denom_t = 2.0 * k1c * k2c * np.cos(k2c * L) - 1j * (k1c**2 + k2c**2) * np.sin(k2c * L)
            if np.abs(denom_t) < 1e-16:
                t_amp = 0.0
                r_amp = 1.0
            else:
                t_amp = (2.0 * k1c * k2c * np.exp(-1j * k1c * L)) / denom_t
                r_amp = (1j * (k2c**2 - k1c**2) * np.sin(k2c * L)) / denom_t
        except Exception:
            t_amp = 0.0
            r_amp = 1.0

        if np.any(left_mask):
            psi[left_mask] = np.exp(1j * k1 * x[left_mask]) + r_amp * np.exp(-1j * k1 * x[left_mask])

        if np.any(mid_mask):
            try:
                x0 = 0.0
                xL = L
                M = np.array([
                    [np.exp(1j * k2c * x0), np.exp(-1j * k2c * x0)],
                    [1j * k2c * np.exp(1j * k2c * x0), -1j * k2c * np.exp(-1j * k2c * x0)]
                ], dtype=complex)
                psi_left_0 = 1.0 + r_amp
                psi_left_der_0 = 1j * k1 * (1.0 - r_amp)
                b = np.array([psi_left_0, psi_left_der_0], dtype=complex)
                sol = linalg.solve(M, b)
                Acoef, Bcoef = sol[0], sol[1]
            except Exception:
                Acoef, Bcoef = 0.0, 0.0

            psi[mid_mask] = Acoef * np.exp(1j * k2c * x[mid_mask]) + Bcoef * np.exp(-1j * k2c * x[mid_mask])

        if np.any(right_mask):
            psi[right_mask] = t_amp * np.exp(1j * k1 * x[right_mask])

        psi_real = np.real(psi)
        prob = np.abs(psi)**2
        return psi_real, prob, T, R

# -------------------------------------------------------------------------
# 3. –§–£–ù–ö–¶–Ü–á –í–Ü–ó–£–ê–õ–Ü–ó–ê–¶–Ü–á
# -------------------------------------------------------------------------
def draw_arrow(ax, x1, x2, y, text, color='white'):
    ax.annotate('', xy=(x1, y), xytext=(x2, y), arrowprops=dict(arrowstyle='<->', color=color))
    ax.text((x1 + x2) / 2.0, y, text, ha='center', va='bottom', color=color,
            bbox=dict(facecolor='#0e1117', alpha=0.9, edgecolor='none', boxstyle='round,pad=0.1'))

def plot_setup(ax, title, U_max):
    ax.set_title(title, color='white')
    ax.set_xlabel("x (–º)", color='white')
    ax.set_ylabel("–ï–Ω–µ—Ä–≥—ñ—è / Œ®", color='white')
    ymin = -abs(U_max) * 0.12
    ymax = abs(U_max) * 1.6 + 1e-30
    ax.set_ylim(ymin, ymax)
    ax.tick_params(colors='white')
    for spine in ['left', 'bottom', 'right', 'top']:
        ax.spines[spine].set_color('white')
    ax.set_facecolor('#0e1117')
    fig = ax.figure
    fig.patch.set_facecolor('#0e1117')

# -------------------------------------------------------------------------
# 4. –ì–û–õ–û–í–ù–ê –õ–û–ì–Ü–ö–ê –ú–û–î–£–õ–Ø (–í–ò–ü–†–ê–í–õ–ï–ù–ê –°–ò–ì–ù–ê–¢–£–†–ê)
# -------------------------------------------------------------------------
def run_barrier_sim(input_params=None, input_sub_type=None):
    """
    –¶—è —Ñ—É–Ω–∫—Ü—ñ—è –≤–∏–∫–ª–∏–∫–∞—î—Ç—å—Å—è –∑ –≥–æ–ª–æ–≤–Ω–æ–≥–æ —Ñ–∞–π–ª—É.
    –ü–∞—Ä–∞–º–µ—Ç—Ä–∏ input_params —ñ input_sub_type —î –Ω–µ–æ–±–æ–≤'—è–∑–∫–æ–≤–∏–º–∏.
    –¶–µ –≤–∏–ø—Ä–∞–≤–ª—è—î –ø–æ–º–∏–ª–∫—É 'takes 0 positional arguments but 2 were given'.
    """
    show_results = False
    
    # –Ø–∫—â–æ –ø–∞—Ä–∞–º–µ—Ç—Ä–∏ –Ω–µ –ø–µ—Ä–µ–¥–∞–Ω—ñ (–∞–≤—Ç–æ–Ω–æ–º–Ω–∏–π –∑–∞–ø—É—Å–∫ –∞–±–æ –ø–µ—Ä—à–∏–π –≤—Ö—ñ–¥)
    if input_params is None:
        if 'run_calc_barrier' not in st.session_state:
            st.session_state['run_calc_barrier'] = False

        st.sidebar.title("üéõ –ü–∞–Ω–µ–ª—å –ö–µ—Ä—É–≤–∞–Ω–Ω—è (–ë–∞—Ä'—î—Ä)")

        sys_type = "–ü–æ—Ç–µ–Ω—Ü—ñ–∞–ª—å–Ω–∏–π –ë–∞—Ä'—î—Ä"
        sub_type = st.sidebar.radio("–¢–∏–ø –±–∞—Ä'—î—Ä—É:", ["–°—Ö–æ–¥–∏–Ω–∫–∞", "–ü—Ä—è–º–æ–∫—É—Ç–Ω–∏–π –±–∞—Ä'—î—Ä"])

        st.sidebar.markdown("---")
        st.sidebar.header("–ü–∞—Ä–∞–º–µ—Ç—Ä–∏")

        params = {}

        # –ß–∞—Å—Ç–∏–Ω–∫–∞
        particle_name = st.sidebar.selectbox("–ß–∞—Å—Ç–∏–Ω–∫–∞:", ["–ï–ª–µ–∫—Ç—Ä–æ–Ω", "–ü—Ä–æ—Ç–æ–Ω", "–ú—é–æ–Ω"])
        mass_map = {"–ï–ª–µ–∫—Ç—Ä–æ–Ω": M_E, "–ü—Ä–æ—Ç–æ–Ω": M_P, "–ú—é–æ–Ω": M_E * 206.768}
        params['m'] = float(mass_map[particle_name])

        # –ü–∞—Ä–∞–º–µ—Ç—Ä–∏ L
        if sub_type == "–ü—Ä—è–º–æ–∫—É—Ç–Ω–∏–π –±–∞—Ä'—î—Ä":
            params['L'] = st.sidebar.number_input("–®–∏—Ä–∏–Ω–∞ L (–º)", value=1e-20, step=1e-10, format="%.2e")
        else:
            params['L'] = 0.0 

        # –ü–æ—Ç–µ–Ω—Ü—ñ–∞–ª U0, –µ–Ω–µ—Ä–≥—ñ—è E
        params['U0'] = st.sidebar.number_input("–ü–æ—Ç–µ–Ω—Ü—ñ–∞–ª U‚ÇÄ (–î–∂)", value=50.0 * EV, step=1.6e-20, format="%.2e")
        params['E'] = st.sidebar.number_input("–ï–Ω–µ—Ä–≥—ñ—è E (–î–∂)", value=5.0 * EV, step=1.6e-20, format="%.2e")

        st.sidebar.markdown("---")
        if st.sidebar.button("üöÄ –†–û–ó–†–ê–•–£–í–ê–¢–ò"):
            st.session_state['run_calc_barrier'] = True
            
        show_results = st.session_state.get('run_calc_barrier', False)
        
    else:
        # –†–µ–∂–∏–º –≤–∏–∫–ª–∏–∫—É –∑ main.py –∑ –ø–µ—Ä–µ–¥–∞–Ω–∏–º–∏ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞–º–∏
        params = input_params
        sub_type = input_sub_type
        show_results = True

    # –í—ñ–¥–æ–±—Ä–∞–∂–µ–Ω–Ω—è —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ñ–≤
    if show_results:
        st.title(f"–†–µ–∑—É–ª—å—Ç–∞—Ç–∏: {sub_type}")
        m = params.get('m', M_E)
        L = params.get('L', 1e-9)
        U0 = params.get('U0', 0.0)
        E = params.get('E', 0.0)

        # ------------------------------------------------------------------
        # 1. –°–•–û–î–ò–ù–ö–ê
        # ------------------------------------------------------------------
        if sub_type == "–°—Ö–æ–¥–∏–Ω–∫–∞":
            m_val = m
            E_val = E
            U0_val = U0
            x_viz = np.linspace(-2e-9, 2e-9, 1000)

            solver = BarrierSolver(m_val)
            psi_real, psi_prob, T, R = solver.solve_step(E_val, U0_val, x_viz)

            # –í–∏–≤–æ–¥–∏–º–æ –º–µ—Ç—Ä–∏–∫–∏
            col1, col2 = st.columns([1, 2])
            with col1:
                st.metric("T (–ü—Ä–æ–ø—É—Å–∫–∞–Ω–Ω—è)", f"{T:.6f}")
                st.metric("R (–í—ñ–¥–±–∏—Ç—Ç—è)", f"{R:.6f}")

            with col2:
                fig, ax = plt.subplots(figsize=(10, 5))
                plot_setup(ax, "–ü–æ—Ç–µ–Ω—Ü—ñ–∞–ª—å–Ω–∞ –°—Ö–æ–¥–∏–Ω–∫–∞", max(E_val, U0_val, 1e-20))
                U_viz = np.where(x_viz > 0, U0_val, 0.0)
                ax.plot(x_viz, U_viz, 'w-', lw=2, label='U(x)')
                ax.axhline(E_val, color='r', ls='--', label='E')

                # –ù–æ—Ä–º–∞–ª—ñ–∑–∞—Ü—ñ—è –¥–ª—è –º–∞–ª—é–≤–∞–Ω–Ω—è
                if np.max(np.abs(psi_real)) > 0:
                    psi_plot = E_val + psi_real / np.max(np.abs(psi_real)) * (abs(E_val) + 0.5 * abs(U0_val) + 1e-20)
                else:
                    psi_plot = E_val + psi_real

                ax.plot(x_viz, psi_plot, color='cyan', label=r'Re($\Psi$)')
                ax.plot(x_viz, E_val + psi_prob / (np.max(psi_prob) + 1e-30) * (abs(E_val) + 0.5 * abs(U0_val) + 1e-20),
                        color='green', ls=':', label=r'$|\Psi|^2$')

                ax.legend(loc='upper right')
                st.pyplot(fig)

        # ------------------------------------------------------------------
        # 2. –ü–†–Ø–ú–û–ö–£–¢–ù–ò–ô –ë–ê–†'–Ñ–†
        # ------------------------------------------------------------------
        elif sub_type == "–ü—Ä—è–º–æ–∫—É—Ç–Ω–∏–π –±–∞—Ä'—î—Ä":
            m_val = m
            E_val = E
            U0_val = U0
            L_val = L

            solver = BarrierSolver(m_val)
            x = np.linspace(-2.0 * L_val, 3.0 * L_val, 1200)
            psi_real, psi_prob, T, R = solver.solve_rectangular(E_val, U0_val, L_val, x)

            # –ú–µ—Ç—Ä–∏–∫–∏
            st.metric("T (–ü—Ä–æ–ø—É—Å–∫–∞–Ω–Ω—è)", f"{T:.6e}")
            st.metric("R (–í—ñ–¥–±–∏—Ç—Ç—è)", f"{R:.6f}")

            # –í—ñ–∑—É–∞–ª—ñ–∑–∞—Ü—ñ—è
            fig, ax = plt.subplots(figsize=(11, 6))
            plot_setup(ax, "–ü—Ä—è–º–æ–∫—É—Ç–Ω–∏–π –ë–∞—Ä'—î—Ä", max(E_val, U0_val, 1e-20))
            U_viz = np.zeros_like(x)
            U_viz[(x >= 0) & (x <= L_val)] = U0_val
            ax.plot(x, U_viz, 'w-', lw=2, label='U(x)')
            ax.axhline(E_val, color='r', ls='--', label='E')

            # –ù–æ—Ä–º–∞–ª—ñ–∑–∞—Ü—ñ—è —Ö–≤–∏–ª—ñ
            if np.max(np.abs(psi_real)) > 0:
                psi_plot = E_val + psi_real / np.max(np.abs(psi_real)) * (max(U0_val, E_val) * 0.4 + 1e-20)
            else:
                psi_plot = E_val + psi_real

            if np.max(psi_prob) > 0:
                prob_plot = E_val + psi_prob / np.max(psi_prob) * (max(U0_val, E_val) * 0.4 + 1e-20)
            else:
                prob_plot = E_val + psi_prob

            ax.plot(x, psi_plot, color='cyan', alpha=0.85, label=r'Re($\Psi$)')
            ax.plot(x, prob_plot, color='lime', ls=':', label=r'$|\Psi|^2$')
            draw_arrow(ax, 0.0, L_val, U0_val * 1.05, "L")
            ax.legend(loc='upper right')
            st.pyplot(fig)

    elif input_params is None:
        st.title("–ö–≤–∞–Ω—Ç–æ–≤–∏–π –ë–∞—Ä'—î—Ä")
        st.markdown("–ù–∞–ª–∞—à—Ç—É–π—Ç–µ –ø–∞—Ä–∞–º–µ—Ç—Ä–∏ –∑–ª—ñ–≤–∞ —Ç–∞ –Ω–∞—Ç–∏—Å–Ω—ñ—Ç—å **üöÄ –†–û–ó–†–ê–•–£–í–ê–¢–ò**.")

if __name__ == "__main__":
    # –î–ª—è —Ç–µ—Å—Ç—É–≤–∞–Ω–Ω—è –º–æ–∂–Ω–∞ –∑–∞–ø—É—Å—Ç–∏—Ç–∏ —è–∫ —Å–∫—Ä–∏–ø—Ç
    st.set_page_config(layout="wide", page_title="–¢–µ—Å—Ç –ú–æ–¥—É–ª—è –ë–∞—Ä'—î—Ä—ñ–≤")
    run_barrier_sim()

################ FILE: ./modules/oscillator.py ################

import streamlit as st
import numpy as np
import matplotlib.pyplot as plt
import math
from scipy.special import hermite, factorial

# –ü–æ–ø—ã—Ç–∫–∞ –∏–º–ø–æ—Ä—Ç–∞ —É—Ç–∏–ª–∏—Ç (–¥–ª—è —Ä–∞–±–æ—Ç—ã –∏ –∫–∞–∫ –º–æ–¥—É–ª—å, –∏ –æ—Ç–¥–µ–ª—å–Ω–æ)
try:
    from .utils import HBAR, EV, M_E, plot_setup, draw_arrow
except ImportError:
    from utils import HBAR, EV, M_E, plot_setup, draw_arrow
# --- –ú–ê–¢–ï–ú–ê–¢–ò–ö–ê ---

def calc_harmonic_energy(omega, n):
    """E_n = hbar * omega * (n + 0.5)"""
    return HBAR * omega * (n + 0.5)

def solve_oscillator(omega, m, n_max=10):
    """–°–ø–∏—Å–æ–∫ —ç–Ω–µ—Ä–≥–∏–π"""
    return [calc_harmonic_energy(omega, n) for n in range(n_max + 1)]

def psi_oscillator(x, m, omega, n):
    """–•–≤–∏–ª—å–æ–≤–∞ —Ñ—É–Ω–∫—Ü—ñ—è (–ï—Ä–º—ñ—Ç)"""
    alpha = np.sqrt(m * omega / HBAR)
    xi = alpha * x
    if n > 50: n = 50
    norm_coef = 1.0 / np.sqrt((2**n) * math.factorial(n)) * np.sqrt(alpha / np.sqrt(np.pi))
    Hn = hermite(n)
    psi = norm_coef * np.exp(-0.5 * xi**2) * Hn(xi)
    return np.real(psi)

# --- –í–Ü–ó–£–ê–õ–Ü–ó–ê–¶–Ü–Ø ---

def run_oscillator_sim(params):
    st.markdown("## „Ä∞Ô∏è –ì–∞—Ä–º–æ–Ω—ñ—á–Ω–∏–π –û—Å—Ü–∏–ª—è—Ç–æ—Ä")
    
    # --- –û–ü–ò–° –¢–ê –¢–ï–û–†–Ü–Ø (–ù–û–í–ï!) ---
    with st.expander("üìö –©–æ —Ü–µ —Ç–∞–∫–µ? (–¢–µ–æ—Ä—ñ—è —Ç–∞ –ø—Ä–∏–∫–ª–∞–¥–∏)", expanded=False):
        st.markdown(r"""
        **–ö–≤–∞–Ω—Ç–æ–≤–∏–π –≥–∞—Ä–º–æ–Ω—ñ—á–Ω–∏–π –æ—Å—Ü–∏–ª—è—Ç–æ—Ä** ‚Äî —Ü–µ –æ–¥–Ω–∞ –∑ –Ω–∞–π–≤–∞–∂–ª–∏–≤—ñ—à–∏—Ö –º–æ–¥–µ–ª–µ–π —É –∫–≤–∞–Ω—Ç–æ–≤—ñ–π –º–µ—Ö–∞–Ω—ñ—Ü—ñ. –í–æ–Ω–∞ –æ–ø–∏—Å—É—î —á–∞—Å—Ç–∏–Ω–∫—É, —â–æ –∑–Ω–∞—Ö–æ–¥–∏—Ç—å—Å—è –≤ –ø–∞—Ä–∞–±–æ–ª—ñ—á–Ω–æ–º—É –ø–æ—Ç–µ–Ω—Ü—ñ–∞–ª—ñ $U(x) = \frac{1}{2}m\omega^2 x^2$.
        
        ### üîπ –û—Å–Ω–æ–≤–Ω—ñ –≤–ª–∞—Å—Ç–∏–≤–æ—Å—Ç—ñ:
        1.  **–ö–≤–∞–Ω—Ç—É–≤–∞–Ω–Ω—è –µ–Ω–µ—Ä–≥—ñ—ó:** –†—ñ–≤–Ω—ñ –µ–Ω–µ—Ä–≥—ñ—ó —Ä–æ–∑—Ç–∞—à–æ–≤–∞–Ω—ñ –Ω–∞ —Ä—ñ–≤–Ω–∏—Ö –≤—ñ–¥—Å—Ç–∞–Ω—è—Ö:
            $$ E_n = \hbar \omega \left(n + \frac{1}{2}\right) $$
        2.  **–ù—É–ª—å–æ–≤–∞ –µ–Ω–µ—Ä–≥—ñ—è:** –ù–∞–≤—ñ—Ç—å –ø—Ä–∏ $n=0$ –µ–Ω–µ—Ä–≥—ñ—è –Ω–µ –¥–æ—Ä—ñ–≤–Ω—é—î –Ω—É–ª—é ($E_0 = \hbar\omega/2$). –¶–µ –Ω–∞—Å–ª—ñ–¥–æ–∫ –ø—Ä–∏–Ω—Ü–∏–ø—É –Ω–µ–≤–∏–∑–Ω–∞—á–µ–Ω–æ—Å—Ç—ñ.
        3.  **–¢—É–Ω–µ–ª—é–≤–∞–Ω–Ω—è:** –•–≤–∏–ª—å–æ–≤–∞ —Ñ—É–Ω–∫—Ü—ñ—è –ø—Ä–æ–Ω–∏–∫–∞—î –≤ –∫–ª–∞—Å–∏—á–Ω–æ –∑–∞–±–æ—Ä–æ–Ω–µ–Ω—É –æ–±–ª–∞—Å—Ç—å (–∑–∞ –º–µ–∂—ñ –ø–∞—Ä–∞–±–æ–ª–∏).

        ### üîπ –ü—Ä–∏–∫–ª–∞–¥–∏ –≤ –ø—Ä–∏—Ä–æ–¥—ñ:
        * **–ö–æ–ª–∏–≤–∞–Ω–Ω—è –∞—Ç–æ–º—ñ–≤ —É –º–æ–ª–µ–∫—É–ª–∞—Ö** (–Ω–∞–ø—Ä–∏–∫–ª–∞–¥, –¥–≤–æ–∞—Ç–æ–º–Ω–∞ –º–æ–ª–µ–∫—É–ª–∞ —è–∫ –ø—Ä—É–∂–∏–Ω–∫–∞).
        * **–§–æ–Ω–æ–Ω–∏** (–∫–æ–ª–∏–≤–∞–Ω–Ω—è –∫—Ä–∏—Å—Ç–∞–ª—ñ—á–Ω–æ—ó “ë—Ä–∞—Ç–∫–∏).
        * **–ï–ª–µ–∫—Ç—Ä–æ–º–∞–≥–Ω—ñ—Ç–Ω–µ –ø–æ–ª–µ** –≤ –∫–≤–∞–Ω—Ç–æ–≤—ñ–π –æ–ø—Ç–∏—Ü—ñ (—Ñ–æ—Ç–æ–Ω–∏).
        """)

    # --- –ì–†–ê–§–Ü–ö ---
    omega, m = params['omega'], params['m']
    energies = solve_oscillator(omega, m, 10)
    
    n_viz = st.slider("–û–±–µ—Ä—ñ—Ç—å –∫–≤–∞–Ω—Ç–æ–≤–∏–π —Ä—ñ–≤–µ–Ω—å n", 0, 5, 0, key="osc_n_slider_internal")
    E_n = energies[n_viz]
    
    st.success(f"–†—ñ–≤–µ–Ω—å n={n_viz}: E = {E_n:.4e} –î–∂ ({E_n/EV:.4f} –µ–í)")
    
    # –¢–µ–º–Ω–∏–π —Å—Ç–∏–ª—å –¥–ª—è –≥—Ä–∞—Ñ—ñ–∫–∞ (—è–∫ –Ω–∞ —Å–∫—Ä—ñ–Ω—à–æ—Ç—ñ)
    plt.style.use('dark_background')
    fig, ax = plt.subplots(figsize=(10, 6))
    
    # –ö–æ–ª—ñ—Ä —Ñ–æ–Ω—É —Å–∞–º–æ–≥–æ –≥—Ä–∞—Ñ—ñ–∫–∞ —ñ —Ñ—ñ–≥—É—Ä–∏
    fig.patch.set_facecolor('#0e1117') 
    ax.set_facecolor('#0e1117')
    
    # –ú–µ–∂—ñ
    if m > 0 and omega > 0 and E_n > 0:
        x_turn = np.sqrt(2.0 * E_n / (m * omega**2))
        x_turn_max = np.sqrt(2.0 * energies[-1] / (m * omega**2))
    else:
        x_turn, x_turn_max = 1e-9, 1e-9
        
    x_lim = max(x_turn_max * 1.3, 1e-10)
    x = np.linspace(-x_lim, x_lim, 800)
    
    # –ü–æ—Ç–µ–Ω—Ü—ñ–∞–ª (–ë—ñ–ª–∞ –ª—ñ–Ω—ñ—è)
    U = 0.5 * m * omega**2 * x**2
    ax.plot(x, U, color='white', linewidth=2, label='U(x)')
    
    # –•–≤–∏–ª—è
    psi = psi_oscillator(x, m, omega, n_viz)
    
    # –ú–∞—Å—à—Ç–∞–±—É–≤–∞–Ω–Ω—è —Ö–≤–∏–ª—ñ, —â–æ–± –≤–æ–Ω–∞ –≥–∞—Ä–Ω–æ –≤–∏–≥–ª—è–¥–∞–ª–∞ –Ω–∞ —Ñ–æ–Ω—ñ –µ–Ω–µ—Ä–≥—ñ—ó
    scale = (energies[1] - energies[0]) * 0.8
    psi_plot = E_n + psi / np.max(np.abs(psi)) * scale
    prob_plot = E_n + (psi**2) / np.max(psi**2) * scale

    # –õ—ñ–Ω—ñ—ó
    ax.plot(x, psi_plot, label=r'$\Psi$', color='cyan', linewidth=2)
    ax.plot(x, prob_plot, label=r'$|\Psi|^2$', color='magenta', linestyle=':', linewidth=2)
    
    # –ó–∞–ª–∏–≤–∫–∞ –ø—ñ–¥ –∫–≤–∞–¥—Ä–∞—Ç–æ–º –º–æ–¥—É–ª—è (–ø—É—Ä–ø—É—Ä–Ω–∞, –Ω–∞–ø—ñ–≤–ø—Ä–æ–∑–æ—Ä–∞)
    ax.fill_between(x, E_n, prob_plot, color='magenta', alpha=0.2)
    
    # –†—ñ–≤–µ–Ω—å –µ–Ω–µ—Ä–≥—ñ—ó (—á–µ—Ä–≤–æ–Ω–∏–π –ø—É–Ω–∫—Ç–∏—Ä)
    ax.hlines(E_n, -x_lim, x_lim, colors='red', linestyles='--', linewidth=1, label=f'E_{n_viz}')
    
    # –°—Ç—Ä—ñ–ª–∫–∞ —à–∏—Ä–∏–Ω–∏ (2A)
    draw_arrow(ax, -x_turn, x_turn, E_n * 1.05, f"2A={2.0 * x_turn:.1e} –º", color='white')

    # –ù–∞–ª–∞—à—Ç—É–≤–∞–Ω–Ω—è –æ—Å–µ–π (–±—ñ–ª—ñ –ø—ñ–¥–ø–∏—Å–∏)
    ax.set_xlabel("x (–º)", color='white', fontsize=12)
    ax.set_ylabel("–ï–Ω–µ—Ä–≥—ñ—è / Œ®", color='white', fontsize=12)
    ax.set_title(f"–ì–∞—Ä–º–æ–Ω—ñ—á–Ω–∏–π –û—Å—Ü–∏–ª—è—Ç–æ—Ä (n={n_viz})", color='white', fontsize=14)
    
    # –ö–æ–ª—ñ—Ä –ø–æ–¥—ñ–ª–æ–∫
    ax.tick_params(axis='x', colors='white')
    ax.tick_params(axis='y', colors='white')
    
    # –†–∞–º–∫–∞ (spines)
    for spine in ax.spines.values():
        spine.set_edgecolor('white')

    ax.legend(loc='upper right', facecolor='#0e1117', labelcolor='white')
    st.pyplot(fig)

# --- –ì–û–õ–û–í–ù–ê –§–£–ù–ö–¶–Ü–Ø –ú–û–î–£–õ–Ø ---

def main():
    st.set_page_config(page_title="–ì–∞—Ä–º–æ–Ω—ñ—á–Ω–∏–π –û—Å—Ü–∏–ª—è—Ç–æ—Ä", layout="wide")
    st.sidebar.header("–ù–∞–ª–∞—à—Ç—É–≤–∞–Ω–Ω—è")
    
    from scipy import constants
    
    p_name = st.sidebar.selectbox("–ß–∞—Å—Ç–∏–Ω–∫–∞:", ["–ï–ª–µ–∫—Ç—Ä–æ–Ω", "–ü—Ä–æ—Ç–æ–Ω", "–ú—é–æ–Ω"], key="osc_p")
    mass_map = {"–ï–ª–µ–∫—Ç—Ä–æ–Ω": constants.m_e, "–ü—Ä–æ—Ç–æ–Ω": constants.m_p, "–ú—é–æ–Ω": constants.m_e * 207}
    
    params = {}
    params['m'] = float(mass_map[p_name])
    params['omega'] = st.sidebar.number_input("–ß–∞—Å—Ç–æ—Ç–∞ œâ (—Ä–∞–¥/—Å)", value=5e15, format="%.2e", step=1e14, key="osc_w")
    
    if st.sidebar.button("–†–æ–∑—Ä–∞—Ö—É–≤–∞—Ç–∏", key="osc_btn"):
        run_oscillator_sim(params)

if __name__ == "__main__":
    main()

################ FILE: ./modules/__init__.py ################

# modules/__init__.py
from .utils import simps, M_E, EV

__all__ = ["simps", "M_E", "EV"]

################ FILE: ./modules/utils.py ################

import matplotlib.pyplot as plt
import cmath
from scipy import constants

# --- –ö–û–ù–°–¢–ê–ù–¢–ò ---
HBAR = constants.hbar
M_E = constants.m_e
EV = constants.electron_volt

# --- –§–£–ù–ö–¶–Ü–á ---

def get_k(E, m, U=0):
    """–†–æ–∑—Ä–∞—Ö–æ–≤—É—î —Ö–≤–∏–ª—å–æ–≤–∏–π –≤–µ–∫—Ç–æ—Ä k."""
    if m <= 0: return 0.0
    val = 2 * m * (E - U)
    return cmath.sqrt(val) / HBAR

def plot_setup(ax, title, U_max=None):
    """–ë–∞–∑–æ–≤–µ –Ω–∞–ª–∞—à—Ç—É–≤–∞–Ω–Ω—è –≥—Ä–∞—Ñ—ñ–∫—ñ–≤ (—Ç–µ–º–Ω–∞ —Ç–µ–º–∞)."""
    ax.set_title(title, color='white', fontsize=14)
    ax.set_xlabel("x (–º)", color='white')
    ax.set_ylabel("–ï–Ω–µ—Ä–≥—ñ—è / Œ®", color='white')
    
    # –ù–∞–ª–∞—à—Ç—É–≤–∞–Ω–Ω—è –∫–æ–ª—å–æ—Ä—ñ–≤ –¥–ª—è —Ç–µ–º–Ω–æ—ó —Ç–µ–º–∏
    ax.set_facecolor('#0e1117')
    fig = ax.figure
    fig.patch.set_facecolor('#0e1117')
    
    ax.tick_params(colors='white')
    for spine in ['left', 'bottom', 'right', 'top']:
        ax.spines[spine].set_color('white')
        
    ax.grid(True, linestyle=':', alpha=0.3, color='gray')

def draw_arrow(ax, x1, x2, y, text, color='white'):
    """–ú–∞–ª—é—î —Å—Ç—Ä—ñ–ª–∫—É —Ä–æ–∑–º—ñ—Ä—É."""
    if abs(x2 - x1) < 1e-20: return
    ax.annotate('', xy=(x1, y), xytext=(x2, y), arrowprops=dict(arrowstyle='<->', color=color))
    ax.text((x1 + x2) / 2.0, y, text, ha='center', va='bottom', color=color,
            bbox=dict(facecolor='#0e1117', alpha=0.9, edgecolor='none', boxstyle='round,pad=0.1'))

################ FILE: ./modules/wavepacket.py ################

import streamlit as st
import numpy as np
import matplotlib.pyplot as plt
from scipy import sparse
from scipy.sparse.linalg import splu
# –Ü–º–ø–æ—Ä—Ç—É—î–º–æ –¢–Ü–õ–¨–ö–ò —Ç–µ, —â–æ —Ä–µ–∞–ª—å–Ω–æ —î –≤ utils.py
from .utils import HBAR, EV, plot_setup, M_E

class TimeDependentSolver:
    def __init__(self, m, Nx=400, L_space=4e-8):
        self.m = m
        self.Nx = Nx
        self.L_space = L_space
        self.x = np.linspace(0, L_space, Nx)
        self.dx = self.x[1] - self.x[0]
        self.dt = 1e-17 

    def simulate_packet(self, E_kin, U0, barrier_width):
        V = np.zeros(self.Nx)
        center = int(self.Nx * 0.5)
        w_idx = int(barrier_width / self.dx)
        V[center : center + w_idx] = U0
        
        # –•–≤–∏–ª—å–æ–≤–∏–π –≤–µ–∫—Ç–æ—Ä k0
        k0 = np.sqrt(2 * self.m * E_kin) / HBAR
        x0 = self.L_space * 0.2
        sigma = self.L_space * 0.05
        
        # –ü–æ—á–∞—Ç–∫–æ–≤–∏–π —Ö–≤–∏–ª—å–æ–≤–∏–π –ø–∞–∫–µ—Ç (–ì–∞—É—Å—Å)
        psi = np.exp(-0.5 * ((self.x - x0)/sigma)**2) * np.exp(1j * k0 * self.x)
        
        # –ù–û–†–ú–ê–õ–Ü–ó–ê–¶–Ü–Ø (–í–∏–ø—Ä–∞–≤–ª–µ–Ω–æ: –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î–º–æ np.trapz –∑–∞–º—ñ—Å—Ç—å simps)
        norm = np.sqrt(np.trapz(np.abs(psi)**2, self.x))
        if norm > 0:
            psi /= norm
        
        # –ü–æ–±—É–¥–æ–≤–∞ –ì–∞–º—ñ–ª—å—Ç–æ–Ω—ñ–∞–Ω–∞ (Crank-Nicolson)
        h_val = HBAR**2 / (2 * self.m * self.dx**2)
        diag = np.full(self.Nx, 2*h_val) + V
        off = np.full(self.Nx-1, -h_val)
        H = sparse.diags([off, diag, off], [-1, 0, 1], shape=(self.Nx, self.Nx))
        
        factor = 1j * self.dt / (2 * HBAR)
        self.A = sparse.eye(self.Nx) + factor * H
        self.B = sparse.eye(self.Nx) - factor * H
        
        return self.x, psi, self.A, self.B, V

def run_wave_packet_simulation(params):
    # –î–æ–¥–∞—î–º–æ –∫–ª—é—á, —â–æ–± –∫–Ω–æ–ø–∫–∞ –Ω–µ –∫–æ–Ω—Ñ–ª—ñ–∫—Ç—É–≤–∞–ª–∞
    if st.button("‚ñ∂Ô∏è –°—Ç–∞—Ä—Ç", key="wp_start_btn"):
        solver = TimeDependentSolver(params['m'], Nx=400, L_space=4e-8)
        # –ó–∞–ø—É—Å–∫–∞—î–º–æ —Å–∏–º—É–ª—è—Ü—ñ—é
        x, psi, A, B, V = solver.simulate_packet(params['E'], params['U0'], barrier_width=2e-9)
        
        plot_spot = st.empty()
        
        # –ü—ñ–¥–≥–æ—Ç–æ–≤–∫–∞ —Ä–æ–∑–≤'—è–∑—É–≤–∞—á–∞ –¥–ª—è –ø—Ä–∏—Å–∫–æ—Ä–µ–Ω–Ω—è
        try: 
            lu = splu(A.tocsc())
        except: 
            lu = None
            
        # –¶–∏–∫–ª –∞–Ω—ñ–º–∞—Ü—ñ—ó
        for i in range(80):
            rhs = B.dot(psi)
            if lu:
                psi = lu.solve(rhs)
            else:
                psi = sparse.linalg.spsolve(A, rhs)
                
            # –ú–∞–ª—é—î–º–æ –∫–æ–∂–µ–Ω 2-–π –∫–∞–¥—Ä
            if i % 2 == 0:
                fig, ax = plt.subplots(figsize=(10, 4))
                
                # –í–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î–º–æ plot_setup –∑ utils
                try:
                    plot_setup(ax, f"–ß–∞—Å–æ–≤–∞ –µ–≤–æ–ª—é—Ü—ñ—è t={i}", xlabel="x (–º)", ylabel="|Psi|^2")
                except:
                    ax.set_title(f"t={i}")
                    ax.grid(True)
                
                # –ú–∞—Å—à—Ç–∞–±—É–≤–∞–Ω–Ω—è –ø–æ—Ç–µ–Ω—Ü—ñ–∞–ª—É –¥–ª—è –∫—Ä–∞—Å–∏–≤–æ–≥–æ –≤—ñ–¥–æ–±—Ä–∞–∂–µ–Ω–Ω—è
                max_psi = np.max(np.abs(psi)**2)
                scale_V = max_psi / (np.max(V/EV) + 1e-30) if np.max(V)>0 else 0
                
                # –ú–∞–ª—é—î–º–æ –±–∞—Ä'—î—Ä —ñ —Ö–≤–∏–ª—é
                ax.plot(x*1e9, (V/EV) * scale_V, color='gray', alpha=0.5, label="–ë–∞—Ä'—î—Ä")
                ax.plot(x*1e9, np.abs(psi)**2, color='cyan', lw=2, label="–•–≤–∏–ª—è")
                
                ax.set_ylim(0, max_psi * 1.5)
                plot_spot.pyplot(fig)
                plt.close(fig)

# –§—É–Ω–∫—Ü—ñ—è –¥–ª—è –∞–≤—Ç–æ–Ω–æ–º–Ω–æ–≥–æ –∑–∞–ø—É—Å–∫—É (—è–∫—â–æ –∑–∞–ø—É—Å–∫–∞—î—Ç–µ —Ñ–∞–π–ª –Ω–∞–ø—Ä—è–º—É)
def main():
    st.title("üåä –•–≤–∏–ª—å–æ–≤–∏–π –ü–∞–∫–µ—Ç")
    st.sidebar.header("–ù–∞–ª–∞—à—Ç—É–≤–∞–Ω–Ω—è")
    from scipy import constants
    
    params = {}
    params['m'] = constants.m_e
    params['E'] = st.sidebar.number_input("–ï–Ω–µ—Ä–≥—ñ—è E (–µ–í)", value=5.0, step=0.1, key="wp_E") * EV
    params['U0'] = st.sidebar.number_input("–í–∏—Å–æ—Ç–∞ U‚ÇÄ (–µ–í)", value=10.0, step=0.1, key="wp_U0") * EV
    
    run_wave_packet_simulation(params)

if __name__ == "__main__":
    main()

################ FILE: ./modules/wells.py ################

import streamlit as st
import numpy as np
import matplotlib
# –í—Å—Ç–∞–Ω–æ–≤–ª—é—î–º–æ –±–µ–∫–µ–Ω–¥ Agg –¥–ª—è —Å—Ç–∞–±—ñ–ª—å–Ω–æ—Å—Ç—ñ —É Streamlit
matplotlib.use('Agg')
import matplotlib.pyplot as plt
from scipy import constants
from scipy import optimize
from modules.utils import simps

# -------------------------------------------------------------------------
# 1. –ö–û–ù–°–¢–ê–ù–¢–ò
# -------------------------------------------------------------------------
HBAR = constants.hbar
M_E = constants.m_e
M_P = constants.m_p
EV = constants.electron_volt

# –ö–æ–Ω—Ñ—ñ–≥—É—Ä–∞—Ü—ñ—è —Å—Ç–æ—Ä—ñ–Ω–∫–∏ —Ç—ñ–ª—å–∫–∏ –ø—Ä–∏ –ø—Ä—è–º–æ–º—É –∑–∞–ø—É—Å–∫—É
if __name__ == "__main__":
    st.set_page_config(layout="wide", page_title="–ö–≤–∞–Ω—Ç–æ–≤–∞ –Ø–º–∞: –°–∏–º—É–ª—è—Ü—ñ—è")

# –¢–µ–º–Ω–∞ —Ç–µ–º–∞ –¥–ª—è –≥—Ä–∞—Ñ—ñ–∫—ñ–≤
plt.style.use('dark_background')

# -------------------------------------------------------------------------
# 2. –ú–ê–¢–ï–ú–ê–¢–ò–ß–ù–ï –Ø–î–†–û
# -------------------------------------------------------------------------

# –ó–ê–ú–ï–ù–ò–¢–ï –≠–¢–£ –§–£–ù–ö–¶–ò–Æ –ù–ê –°–£–©–ï–°–¢–í–£–Æ–©–£–Æ –í –í–ê–®–ï–ú –§–ê–ô–õ–ï
def solve_finite_well_energies(m, L, U0):
    """
    –ù–∞–¥—ñ–π–Ω–∏–π —Ç–∞ —à–≤–∏–¥–∫–∏–π –ø–æ—à—É–∫ —Ä—ñ–≤–Ω—ñ–≤ –µ–Ω–µ—Ä–≥—ñ—ó –∫—ñ–Ω—Ü–µ–≤–æ—ó —è–º–∏.
    –ü—Ä–∞—Ü—é—î –Ω–∞–≤—ñ—Ç—å –ø—Ä–∏ L ‚âà 0.03 –º –∞–±–æ U‚ÇÄ ‚âà 10‚Å¥ –µ–í.
    """
    if U0 <= 0 or L <= 0:
        return []

    # –ë–µ–∑—Ä–æ–∑–º—ñ—Ä–Ω–∏–π –ø–∞—Ä–∞–º–µ—Ç—Ä Œ∑ = L/2 * ‚àö(2mU‚ÇÄ)/‚Ñè
    # (–≤ –ª—ñ—Ç–µ—Ä–∞—Ç—É—Ä—ñ —á–∞—Å—Ç–æ –ø–æ–∑–Ω–∞—á–∞—é—Ç—å z‚ÇÄ)
    try:
        eta = L/2.0 * np.sqrt(2.0 * m * U0) / HBAR
    except (OverflowError, ValueError):
        return []                                 # –Ω–∞–¥—Ç–æ –≤–µ–ª–∏–∫—ñ —á–∏—Å–ª–∞ ‚Üí —Ä—ñ–≤–Ω—ñ–≤ –Ω–µ–º–∞—î

    # –Ø–∫—â–æ Œ∑ –¥—É–∂–µ –º–∞–ª–µ–Ω—å–∫–µ ‚Äî —Ç–æ—á–Ω–æ –Ω–µ–º–∞—î –∑–≤‚Äô—è–∑–∞–Ω–∏—Ö —Å—Ç–∞–Ω—ñ–≤
    if eta < 1e-6:
        return []

    # –û–±–º–µ–∂—É—î–º–æ –∫—ñ–ª—å–∫—ñ—Å—Ç—å —Ä—ñ–≤–Ω—ñ–≤ —Ä–æ–∑—É–º–Ω–∏–º —á–∏—Å–ª–æ–º (–º–∞–∫—Å–∏–º—É–º ~200)
    # –¶–µ –Ω–∞–π–≤–∞–∂–ª–∏–≤—ñ—à–µ –≤–∏–ø—Ä–∞–≤–ª–µ–Ω–Ω—è ‚Äî –±–µ–∑ –Ω—å–æ–≥–æ —Ü–∏–∫–ª —Å—Ç–∞—î –Ω–µ—Å–∫—ñ–Ω—á–µ–Ω–Ω–∏–º
    max_n = min(200, int(np.ceil(eta / (np.pi/2.0))) + 5)

    roots_z = []
    eps = 1e-8

    # –†—ñ–≤–Ω—è–Ω–Ω—è –¥–ª—è –ø–∞—Ä–Ω–∏—Ö —Å—Ç–∞–Ω—ñ–≤
    def even_eq(z):  
        inside = np.clip((eta/z)**2 - 1.0, 0.0, None)
        return np.tan(z) - np.sqrt(inside)

    # –†—ñ–≤–Ω—è–Ω–Ω—è –¥–ª—è –Ω–µ–ø–∞—Ä–Ω–∏—Ö —Å—Ç–∞–Ω—ñ–≤
    def odd_eq(z):
        inside = np.clip((eta/z)**2 - 1.0, 0.0, None)
        return -1.0/np.tan(z) - np.sqrt(inside)

    for n in range(max_n):
        a = n * np.pi/2.0 + eps
        b = (n + 1) * np.pi/2.0 - eps

        if a >= eta:
            break
        if b > eta:
            b = eta - eps

        if a >= b:
            continue

        # –ø–∞—Ä–Ω—ñ —Å—Ç–∞–Ω–∏
        try:
            fa, fb = even_eq(a), even_eq(b)
            if np.isfinite(fa) and np.isfinite(fb) and fa * fb <= 0:
                root = optimize.brentq(even_eq, a, b, xtol=1e-12, maxiter=100)
                if 0 < root < eta:
                    roots_z.append(('even', root))
        except Exception:
            pass

        # –Ω–µ–ø–∞—Ä–Ω—ñ —Å—Ç–∞–Ω–∏
        try:
            fa, fb = odd_eq(a), odd_eq(b)
            if np.isfinite(fa) and np.isfinite(fb) and fa * fb <= 0:
                root = optimize.brentq(odd_eq, a, b, xtol=1e-12, maxiter=100)
                if 0 < root < eta:
                    roots_z.append(('odd', root))
        except Exception:
            pass

    # –ü–µ—Ä–µ—Ç–≤–æ—Ä—é—î–º–æ –∑–Ω–∞–π–¥–µ–Ω—ñ z —É –µ–Ω–µ—Ä–≥—ñ—é
    energies = []
    for parity, z in roots_z:
        E = (HBAR ** 2 * (2.0 * z / L) ** 2) / (2.0 * m)     # E = ‚Ñè¬≤k¬≤/2m, k = 2z/L
        if E < U0:
            kappa = np.sqrt(2.0 * m * (U0 - E)) / HBAR
            energies.append({
                'E': float(E),
                'k': 2.0 * z / L,
                'kappa': float(kappa),
                'parity': parity
            })

    return sorted(energies, key=lambda x: x['E'])

def solve_inf_well_energies(m, L, n_max=10):
    """–ê–Ω–∞–ª—ñ—Ç–∏—á–Ω–∏–π —Ä–æ–∑—Ä–∞—Ö—É–Ω–æ–∫ –¥–ª—è –Ω–µ—Å–∫—ñ–Ω—á–µ–Ω–Ω–æ—ó —è–º–∏ (–î–∂)."""
    energies = []
    for n in range(1, n_max + 1):
        E = (n**2 * np.pi**2 * HBAR**2) / (2.0 * m * L**2)
        energies.append({'E': E, 'n': n, 'parity': 'even' if n % 2 != 0 else 'odd'})
    return energies

def get_wavefunction_finite(x_math, energy_data, L):
    """
    –•–≤–∏–ª—å–æ–≤–∞ —Ñ—É–Ω–∫—Ü—ñ—è –∫—ñ–Ω—Ü–µ–≤–æ—ó —è–º–∏ (x_math —Ü–µ–Ω—Ç—Ä–æ–≤–∞–Ω–æ –≤ 0).
    –í–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î —Å—Ç–∞–±—ñ–ª—å–Ω—É —Ñ–æ—Ä–º—É–ª—É –¥–ª—è —É–Ω–∏–∫–Ω–µ–Ω–Ω—è –ø–µ—Ä–µ–ø–æ–≤–Ω–µ–Ω–Ω—è –µ–∫—Å–ø–æ–Ω–µ–Ω—Ç–∏.
    """
    psi = np.zeros_like(x_math)
    k, kappa, parity = energy_data['k'], energy_data['kappa'], energy_data['parity']
    a = L / 2.0 
    
    # –ó–∞–º—ñ—Å—Ç—å —Ä–æ–∑—Ä–∞—Ö—É–Ω–∫—É –≤–µ–ª–∏—á–µ–∑–Ω–æ–≥–æ A_out = trig * exp(kappa*a),
    # –º–∏ –æ–±—á–∏—Å–ª—é—î–º–æ –∑–Ω–∞—á–µ–Ω–Ω—è –æ–¥—Ä–∞–∑—É –∑ –∫–æ–º–ø–µ–Ω—Å—É—é—á–æ—é –µ–∫—Å–ø–æ–Ω–µ–Ω—Ç–æ—é exp(-kappa*x).
    # –§–æ—Ä–º—É–ª–∞ –∑–æ–≤–Ω—ñ: trig(ka) * exp(kappa * (a - |x|))
    # –û—Å–∫—ñ–ª—å–∫–∏ |x| > a, —Ç–æ (a - |x|) < 0, —Ç–æ–º—É –µ–∫—Å–ø–æ–Ω–µ–Ω—Ç–∞ –∑–∞–≤–∂–¥–∏ –º–∞–ª–∞ —ñ –±–µ–∑–ø–µ—á–Ω–∞.
    
    val_edge = np.cos(k*a) if parity == 'even' else np.sin(k*a)

    for i, x in enumerate(x_math):
        if abs(x) <= a:
            # –í—Å–µ—Ä–µ–¥–∏–Ω—ñ —è–º–∏
            psi[i] = np.cos(k*x) if parity == 'even' else np.sin(k*x)
        else:
            # –ó–æ–≤–Ω—ñ —è–º–∏ (–±–µ–∑–ø–µ—á–Ω–∏–π —Ä–æ–∑—Ä–∞—Ö—É–Ω–æ–∫)
            exponent = kappa * (a - abs(x))
            # –ó–∞—Ö–∏—Å—Ç –≤—ñ–¥ –∑–∞–Ω–∞–¥—Ç–æ –º–∞–ª–∏—Ö –∑–Ω–∞—á–µ–Ω—å (underflow), —Ö–æ—á–∞ –¥–ª—è float —Ü–µ –Ω–µ –∫—Ä–∏—Ç–∏—á–Ω–æ
            if exponent < -700: 
                val = 0.0
            else:
                val = val_edge * np.exp(exponent)
            
            psi[i] = val if (parity == 'even' or x > 0) else -val
            
    norm = np.sqrt(np.trapz(psi**2, x_math))
    return psi / norm if norm > 0 else psi

def get_wavefunction_inf(x_plot, n, L):
    """–•–≤–∏–ª—å–æ–≤–∞ —Ñ—É–Ω–∫—Ü—ñ—è –Ω–µ—Å–∫—ñ–Ω—á–µ–Ω–Ω–æ—ó —è–º–∏ (x_plot –≤—ñ–¥ 0 –¥–æ L)."""
    psi = np.zeros_like(x_plot)
    mask = (x_plot >= 0) & (x_plot <= L)
    psi[mask] = np.sqrt(2.0 / L) * np.sin(n * np.pi * x_plot[mask] / L)
    return psi

# -------------------------------------------------------------------------
# 3. –§–£–ù–ö–¶–Ü–á –í–Ü–ó–£–ê–õ–Ü–ó–ê–¶–Ü–á
# -------------------------------------------------------------------------

def setup_plot_style(ax, title, xlabel="x (–º)", ylabel="–ï–Ω–µ—Ä–≥—ñ—è (–µ–í)"):
    """–ë–∞–∑–æ–≤–µ –Ω–∞–ª–∞—à—Ç—É–≤–∞–Ω–Ω—è —Å—Ç–∏–ª—é –≥—Ä–∞—Ñ—ñ–∫–∞."""
    ax.set_title(title, color='white', fontsize=16, pad=20)
    ax.set_xlabel(xlabel, color='white', fontsize=12)
    ax.set_ylabel(ylabel, color='white', fontsize=12)
    ax.tick_params(colors='white', labelsize=10)
    ax.set_facecolor('#0E1117') # –¢–µ–º–Ω–∏–π —Ñ–æ–Ω, —è–∫ —É Streamlit
    for spine in ax.spines.values():
        spine.set_color('#444444')
    ax.grid(True, linestyle='--', alpha=0.2, color='white')

def draw_level_and_wave(ax, x, psi, prob, E_ev, L, color_psi='cyan', color_prob='lime'):
    """–ú–∞–ª—é—î —Ä—ñ–≤–µ–Ω—å –µ–Ω–µ—Ä–≥—ñ—ó —Ç–∞ —Ö–≤–∏–ª—å–æ–≤—É —Ñ—É–Ω–∫—Ü—ñ—é –ø–æ–≤–µ—Ä—Ö –Ω—å–æ–≥–æ."""
    
    # –í–∏–∑–Ω–∞—á–∞—î–º–æ –º–∞—Å—à—Ç–∞–± —Ö–≤–∏–ª—ñ.
    scale_factor = E_ev * 0.3 if E_ev > 1e-3 else 1.0
    
    # –ó—Å—É–≤–∞—î–º–æ —Ö–≤–∏–ª—é –Ω–∞ —Ä—ñ–≤–µ–Ω—å –µ–Ω–µ—Ä–≥—ñ—ó E
    psi_shifted = E_ev + psi * scale_factor
    prob_shifted = E_ev + prob * scale_factor
    
    # 1. –õ—ñ–Ω—ñ—è –µ–Ω–µ—Ä–≥—ñ—ó (–ø—É–Ω–∫—Ç–∏—Ä)
    ax.hlines(E_ev, x[0], x[-1], colors='red', linestyles='--', linewidth=1, alpha=0.7)
    
    # 2. –ü—ñ–¥–ø–∏—Å –µ–Ω–µ—Ä–≥—ñ—ó —Å–ø—Ä–∞–≤–∞
    ax.text(x[-1], E_ev, f"  E = {E_ev:.3e} –µ–í", 
            color='red', va='center', fontsize=11, fontweight='bold')
    
    # 3. –•–≤–∏–ª—å–æ–≤–∞ —Ñ—É–Ω–∫—Ü—ñ—è (–õ—ñ–Ω—ñ—è)
    ax.plot(x, psi_shifted, color=color_psi, linewidth=2, label=r'$\Psi(x)$')
    
    # 4. –ó–∞–ª–∏–≤–∫–∞ –ø—ñ–¥ —Ö–≤–∏–ª–µ—é (–Ω–∞–ø—ñ–≤–ø—Ä–æ–∑–æ—Ä–∞)
    ax.fill_between(x, E_ev, psi_shifted, color=color_psi, alpha=0.15)
    
    # 5. –ì—É—Å—Ç–∏–Ω–∞ –π–º–æ–≤—ñ—Ä–Ω–æ—Å—Ç—ñ (–ü—É–Ω–∫—Ç–∏—Ä)
    ax.plot(x, prob_shifted, color=color_prob, linestyle=':', linewidth=2, label=r'$|\Psi|^2$')

# -------------------------------------------------------------------------
# 4. –ï–ö–°–ü–û–†–¢–û–í–ê–ù–Ü –§–£–ù–ö–¶–Ü–á –°–ò–ú–£–õ–Ø–¶–Ü–á
# -------------------------------------------------------------------------

def run_finite_well_sim(params):
    """
    –°–∏–º—É–ª—è—Ü—ñ—è –ö—ñ–Ω—Ü–µ–≤–æ—ó —è–º–∏.
    params: {'m': float, 'L': float, 'U0': float (–î–∂)}
    """
    m = params.get('m', M_E)
    L_val = params.get('L', 1e-9)
    U0_joule = params.get('U0', 10.0 * EV)
    U0_ev = U0_joule / EV

    st.subheader("üì¶ –ö—ñ–Ω—Ü–µ–≤–∞ –ü–æ—Ç–µ–Ω—Ü—ñ–∞–ª—å–Ω–∞ –Ø–º–∞")

    energies = solve_finite_well_energies(m, L_val, U0_joule)
    
    if not energies:
        st.warning(f"‚ö†Ô∏è –ü—Ä–∏ –≥–ª–∏–±–∏–Ω—ñ {U0_ev:.2f} –µ–í —Ç–∞ —à–∏—Ä–∏–Ω—ñ {L_val:.2e} –º –∑–≤'—è–∑–∞–Ω–∏—Ö —Å—Ç–∞–Ω—ñ–≤ –Ω–µ –∑–Ω–∞–π–¥–µ–Ω–æ.")
        return

    # –°–ª–∞–π–¥–µ—Ä –≤–∏–±–æ—Ä—É n
    n = st.slider("–ö–≤–∞–Ω—Ç–æ–≤–µ —á–∏—Å–ª–æ n", 1, 10, 1, key="infinite_n_slider")
    
    state = energies[n-1]
    E_ev = state['E'] / EV
    parity_str = "–ü–∞—Ä–Ω–∞ (Even)" if state['parity']=='even' else "–ù–µ–ø–∞—Ä–Ω–∞ (Odd)"

    # –ú–µ—Ç—Ä–∏–∫–∏
    c1, c2, c3 = st.columns(3)
    c1.metric("–†—ñ–≤–µ–Ω—å", f"n = {n}")
    c2.metric("–ï–Ω–µ—Ä–≥—ñ—è", f"{E_ev:.4e} –µ–í")
    c3.metric("–°–∏–º–µ—Ç—Ä—ñ—è", parity_str)

    # –ì—Ä–∞—Ñ—ñ–∫
    fig, ax = plt.subplots(figsize=(10, 6))
    fig.patch.set_facecolor('#0E1117')
    setup_plot_style(ax, f"–°—Ç–∞—Ü—ñ–æ–Ω–∞—Ä–Ω–∏–π —Å—Ç–∞–Ω n={n}")

    # –î—ñ–∞–ø–∞–∑–æ–Ω X: –≤—ñ–¥ -L –¥–æ 2L (—â–æ–± –ø–æ–∫–∞–∑–∞—Ç–∏ —Ö–≤–æ—Å—Ç–∏)
    x = np.linspace(-L_val*0.8, L_val*1.8, 1000)
    
    # 1. –ú–∞–ª—é—î–º–æ –Ø–º—É (–°—Ç—ñ–Ω–∫–∏)
    ax.fill_between(x, 0, U0_ev, where=(x <= 0), color='#4A90E2', alpha=0.2, label='–°—Ç—ñ–Ω–∫–∏ –±–∞—Ä\'—î—Ä—É')
    ax.fill_between(x, 0, U0_ev, where=(x >= L_val), color='#4A90E2', alpha=0.2)
    
    # –õ—ñ–Ω—ñ—è –ø–æ—Ç–µ–Ω—Ü—ñ–∞–ª—É
    U_pot = np.where((x >= 0) & (x <= L_val), 0, U0_ev)
    ax.plot(x, U_pot, color='white', linewidth=2)
    ax.text(0, U0_ev * 1.02, f" U‚ÇÄ = {U0_ev:.1f} –µ–í", color='white', fontsize=10)

    # 2. –†–æ–∑—Ä–∞—Ö—É–Ω–æ–∫ —Ö–≤–∏–ª—ñ
    x_math = x - L_val/2.0
    psi = get_wavefunction_finite(x_math, state, L_val)
    prob = psi**2
    if np.max(np.abs(psi)) > 0:
        psi /= np.max(np.abs(psi))
        prob /= np.max(prob)

    # 3. –ú–∞–ª—é—î–º–æ —Ö–≤–∏–ª—é —ñ —Ä—ñ–≤–µ–Ω—å
    draw_level_and_wave(ax, x, psi, prob, E_ev, L_val)

    # –ù–∞–ª–∞—à—Ç—É–≤–∞–Ω–Ω—è –º–µ–∂ –æ—Å–µ–π
    y_max_plot = max(U0_ev * 1.3, E_ev * 1.5)
    ax.set_ylim(-y_max_plot * 0.1, y_max_plot)
    ax.set_xlim(x[0], x[-1])

    ax.legend(loc='upper right', facecolor='#262730', labelcolor='white')
    st.pyplot(fig)
    
    # –¢–ï–û–†–Ü–Ø
    st.markdown("---")
    st.markdown("""
    ### üìù –ü–æ—è—Å–Ω–µ–Ω–Ω—è
    –£ –∫—ñ–Ω—Ü–µ–≤—ñ–π —è–º—ñ —Å—Ç—ñ–Ω–∫–∏ –º–∞—é—Ç—å –≤–∏—Å–æ—Ç—É $U_0$. –ß–∞—Å—Ç–∏–Ω–∫–∞ –Ω–µ –∑–∞–ø–µ—Ä—Ç–∞ —ñ–¥–µ–∞–ª—å–Ω–æ:
    * **–í—Å–µ—Ä–µ–¥–∏–Ω—ñ ($0 < x < L$):** –•–≤–∏–ª—å–æ–≤–∞ —Ñ—É–Ω–∫—Ü—ñ—è –æ—Å—Ü–∏–ª—é—î (sin/cos).
    * **–í —Å—Ç—ñ–Ω–∫–∞—Ö ($x < 0, x > L$):** –ï–Ω–µ—Ä–≥—ñ—è —á–∞—Å—Ç–∏–Ω–∫–∏ $E < U_0$, —Ç–æ–º—É –∫—ñ–Ω–µ—Ç–∏—á–Ω–∞ –µ–Ω–µ—Ä–≥—ñ—è —Ñ–æ—Ä–º–∞–ª—å–Ω–æ –≤—ñ–¥'—î–º–Ω–∞. –•–≤–∏–ª—å–æ–≤–∞ —Ñ—É–Ω–∫—Ü—ñ—è –µ–∫—Å–ø–æ–Ω–µ–Ω—Ü—ñ–π–Ω–æ –∑–∞—Ç—É—Ö–∞—î (**–¢—É–Ω–Ω–µ–ª—å–Ω–∏–π –µ—Ñ–µ–∫—Ç**).
    """)

def run_infinite_well_sim(params):
    """
    –°–∏–º—É–ª—è—Ü—ñ—è –ù–µ—Å–∫—ñ–Ω—á–µ–Ω–Ω–æ—ó —è–º–∏.
    params: {'m': float, 'L': float}
    """
    m = params.get('m', M_E)
    L_val = params.get('L', 1e-9)

    st.subheader("üì¶ –ù–µ—Å–∫—ñ–Ω—á–µ–Ω–Ω–∞ –ü–æ—Ç–µ–Ω—Ü—ñ–∞–ª—å–Ω–∞ –Ø–º–∞")

    energies = solve_inf_well_energies(m, L_val, n_max=10)
    E_max_limit = energies[-1]['E'] / EV

    # –°–ª–∞–π–¥–µ—Ä –≤–∏–±–æ—Ä—É n
    n = st.slider("–ö–≤–∞–Ω—Ç–æ–≤–µ —á–∏—Å–ª–æ n", 1, 10, 1, key="infinite_n_slider")
    
    state = energies[n-1]
    E_ev = state['E'] / EV
    parity_str = "–ü–∞—Ä–Ω–∞ (Even)" if n % 2 != 0 else "–ù–µ–ø–∞—Ä–Ω–∞ (Odd)"

    c1, c2, c3 = st.columns(3)
    c1.metric("–†—ñ–≤–µ–Ω—å", f"n = {n}")
    c2.metric("–ï–Ω–µ—Ä–≥—ñ—è", f"{E_ev:.4e} –µ–í")
    c3.metric("–°–∏–º–µ—Ç—Ä—ñ—è", parity_str)

    # –ì—Ä–∞—Ñ—ñ–∫
    fig, ax = plt.subplots(figsize=(10, 6))
    fig.patch.set_facecolor('#0E1117')
    setup_plot_style(ax, f"–°—Ç–∞—Ü—ñ–æ–Ω–∞—Ä–Ω–∏–π —Å—Ç–∞–Ω n={n}")

    # –î—ñ–∞–ø–∞–∑–æ–Ω X
    x = np.linspace(-L_val*0.2, L_val*1.2, 1000)
    
    # 1. –ú–∞–ª—é—î–º–æ –°—Ç—ñ–Ω–∫–∏
    ax.axvline(0, color='white', linewidth=3)
    ax.axvline(L_val, color='white', linewidth=3)
    
    ymax_fill = E_max_limit * 1.5
    ax.fill_between(x, -ymax_fill, ymax_fill, where=(x<0), color='gray', alpha=0.3, hatch='//')
    ax.fill_between(x, -ymax_fill, ymax_fill, where=(x>L_val), color='gray', alpha=0.3, hatch='//')
    ax.hlines(0, 0, L_val, color='white', linewidth=1)

    # 2. –†–æ–∑—Ä–∞—Ö—É–Ω–æ–∫ —Ö–≤–∏–ª—ñ
    psi = get_wavefunction_inf(x, n, L_val)
    prob = psi**2
    if np.max(np.abs(psi)) > 0:
        psi /= np.max(np.abs(psi))
        prob /= np.max(prob)

    # 3. –ú–∞–ª—é—î–º–æ —Ö–≤–∏–ª—é
    draw_level_and_wave(ax, x, psi, prob, E_ev, L_val)

    # –ù–∞–ª–∞—à—Ç—É–≤–∞–Ω–Ω—è –º–µ–∂
    ax.set_ylim(-E_max_limit * 0.1, E_max_limit * 1.2)
    ax.set_xlim(x[0], x[-1])

    ax.legend(loc='upper right', facecolor='#262730', labelcolor='white')
    st.pyplot(fig)
    
    # –¢–ï–û–†–Ü–Ø
    st.markdown("---")
    st.markdown("""
    ### üìù –ü–æ—è—Å–Ω–µ–Ω–Ω—è
    –£ –Ω–µ—Å–∫—ñ–Ω—á–µ–Ω–Ω—ñ–π —è–º—ñ —Å—Ç—ñ–Ω–∫–∏ –∞–±—Å–æ–ª—é—Ç–Ω–æ –Ω–µ–ø—Ä–æ–Ω–∏–∫–Ω—ñ.
    * **–ì—Ä–∞–Ω–∏—á–Ω—ñ —É–º–æ–≤–∏:** $\Psi(0) = 0$ —Ç–∞ $\Psi(L) = 0$.
    * **–ï–Ω–µ—Ä–≥—ñ—è:** $E_n \\sim n^2$. –í—ñ–¥—Å—Ç–∞–Ω—å –º—ñ–∂ —Ä—ñ–≤–Ω—è–º–∏ —à–≤–∏–¥–∫–æ –∑—Ä–æ—Å—Ç–∞—î.
    * –•–≤–∏–ª—å–æ–≤–∞ —Ñ—É–Ω–∫—Ü—ñ—è —Å—Ç—Ä–æ–≥–æ –ª–æ–∫–∞–ª—ñ–∑–æ–≤–∞–Ω–∞ –≤ –º–µ–∂–∞—Ö $0..L$.
    """)

# -------------------------------------------------------------------------
# 5. MAIN ‚Äî –ì–û–¢–û–í–ò–ô –î–õ–Ø –í–°–¢–ê–í–ö–ò
# -------------------------------------------------------------------------
def main():
    st.set_page_config(page_title="–ö–≤–∞–Ω—Ç–æ–≤–∞ –Ø–º–∞", layout="wide")
    st.title("–ö–≤–∞–Ω—Ç–æ–≤–∞ –ø–æ—Ç–µ–Ω—Ü—ñ–∞–ª—å–Ω–∞ —è–º–∞")

    st.sidebar.header("–ù–∞–ª–∞—à—Ç—É–≤–∞–Ω–Ω—è —Å–∏–º—É–ª—è—Ü—ñ—ó")

    # 1. –ß–∞—Å—Ç–∏–Ω–∫–∞
    st.sidebar.subheader("–ß–∞—Å—Ç–∏–Ω–∫–∞")
    particle = st.sidebar.radio(
        "–û–±–µ—Ä—ñ—Ç—å —á–∞—Å—Ç–∏–Ω–∫—É",
        options=["–ï–ª–µ–∫—Ç—Ä–æ–Ω", "–ú—é–æ–Ω", "–ü—Ä–æ—Ç–æ–Ω"],
        index=0,
        horizontal=True,
        label_visibility="collapsed"
    )
    mass_map = {"–ï–ª–µ–∫—Ç—Ä–æ–Ω": M_E, "–ú—é–æ–Ω": 206.768 * M_E, "–ü—Ä–æ—Ç–æ–Ω": M_P}
    m = mass_map[particle]

    # 2. –î–æ–≤–∂–∏–Ω–∞ —è–º–∏
    st.sidebar.subheader("–î–æ–≤–∂–∏–Ω–∞ —è–º–∏")
    L_nm = st.sidebar.slider(
        "L (–Ω–º)",
        min_value=0.1,
        max_value=100.0,
        value=1.0,
        step=0.1,
        format="%.3f"
    )
    L_meters = L_nm * 1e-9
    st.sidebar.markdown(f"**L = {L_nm:.3f} –Ω–º**")

    # 3. –ì–ª–∏–±–∏–Ω–∞ –ø–æ—Ç–µ–Ω—Ü—ñ–∞–ª—É (—Ç—ñ–ª—å–∫–∏ –¥–ª—è –∫—ñ–Ω—Ü–µ–≤–æ—ó —è–º–∏)
    st.sidebar.subheader("–ü–æ—Ç–µ–Ω—Ü—ñ–∞–ª –±–∞—Ä‚Äô—î—Ä—É")
    U0_ev = st.sidebar.number_input(
        "U‚ÇÄ (–µ–í)",
        min_value=0.1,
        value=50.0,
        step=1.0,
        help="–ì–ª–∏–±–∏–Ω–∞ —è–º–∏ –¥–ª—è –∫—ñ–Ω—Ü–µ–≤–æ—ó –º–æ–¥–µ–ª—ñ"
    )

    # –í–∏–±—ñ—Ä —Ç–∏–ø—É —è–º–∏
    well_type = st.sidebar.radio("–¢–∏–ø —è–º–∏", ["–ù–µ—Å–∫—ñ–Ω—á–µ–Ω–Ω–∞ —è–º–∞", "–ö—ñ–Ω—Ü–µ–≤–∞ —è–º–∞"])

    # –ó–ê–ü–£–°–ö –°–ò–ú–£–õ–Ø–¶–Ü–á ‚Äî –û–¶–ï –°–ê–ú–ï –ì–û–õ–û–í–ù–ï!
    if well_type == "–ö—ñ–Ω—Ü–µ–≤–∞ —è–º–∞":
        run_finite_well_sim(m, L_meters, U0_ev * EV)
    else:
        run_infinite_well_sim(m, L_meters)
        

if __name__ == "__main__":
    main()

################ FILE: ./pages/1_Spin.py ################

import streamlit as st
import numpy as np
import plotly.graph_objects as go

# –ù–∞–ª–∞—à—Ç—É–≤–∞–Ω–Ω—è —Å—Ç–æ—Ä—ñ–Ω–∫–∏
st.set_page_config(page_title="–°–ø—ñ–Ω —ñ –°—Ñ–µ—Ä–∞ –ë–ª–æ—Ö–∞", layout="wide")

def run_spin_visualization():
    st.title("üåÄ –ö–≤–∞–Ω—Ç–æ–≤–∏–π –°–ø—ñ–Ω: –°—Ñ–µ—Ä–∞ –ë–ª–æ—Ö–∞")
    
    # –û—Ö–∞–π–Ω–∏–π –æ–ø–∏—Å –±–µ–∑ –∑–∞–π–≤–æ–≥–æ –≤–∏–¥—ñ–ª–µ–Ω–Ω—è
    st.markdown("""
    –°–ø—ñ–Ω –µ–ª–µ–∫—Ç—Ä–æ–Ω–∞ (–∞–±–æ –±—É–¥—å-—è–∫–æ—ó –¥–≤–æ—Ä—ñ–≤–Ω–µ–≤–æ—ó —Å–∏—Å—Ç–µ–º–∏, –Ω–∞–ø—Ä–∏–∫–ª–∞–¥, –∫—É–±—ñ—Ç–∞) –º–æ–∂–Ω–∞ –ø—Ä–µ–¥—Å—Ç–∞–≤–∏—Ç–∏ —è–∫ –≤–µ–∫—Ç–æ—Ä –Ω–∞ –æ–¥–∏–Ω–∏—á–Ω—ñ–π —Å—Ñ–µ—Ä—ñ:
    * **–ü—ñ–≤–Ω—ñ—á–Ω–∏–π –ø–æ–ª—é—Å ($|0\\rangle$):** –°–ø—ñ–Ω –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–π —Ç–æ—á–Ω–æ –í–ì–û–†–£ (+Z).
    * **–ü—ñ–≤–¥–µ–Ω–Ω–∏–π –ø–æ–ª—é—Å ($|1\\rangle$):** –°–ø—ñ–Ω –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–π —Ç–æ—á–Ω–æ –í–ù–ò–ó (-Z).
    * **–ï–∫–≤–∞—Ç–æ—Ä:** –°—Ç–∞–Ω —Å—É–ø–µ—Ä–ø–æ–∑–∏—Ü—ñ—ó (—Å–ø—ñ–Ω –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–π –≤–±—ñ–∫).
    """)
    
    col1, col2 = st.columns([1, 2])
    
    with col1:
        st.subheader("üéõ –ü–∞—Ä–∞–º–µ—Ç—Ä–∏")
        st.info("–û–±–µ—Ä—Ç–∞–π—Ç–µ –≤–µ–∫—Ç–æ—Ä, –∑–º—ñ–Ω—é—é—á–∏ –∫—É—Ç–∏:")
        
        # –°–ª–∞–π–¥–µ—Ä–∏ –¥–ª—è –∫—É—Ç—ñ–≤
        theta = st.slider("–ö—É—Ç Œ∏ (–ü–æ–ª—è—Ä–Ω–∏–π)", 0.0, np.pi, 0.0, 0.01)
        phi = st.slider("–ö—É—Ç œÜ (–ê–∑–∏–º—É—Ç–∞–ª—å–Ω–∏–π)", 0.0, 2*np.pi, 0.0, 0.01)
        
        st.divider()
        st.subheader("üìä –°—Ç–∞–Ω —Å–∏—Å—Ç–µ–º–∏")
        
        # –†–æ–∑—Ä–∞—Ö—É–Ω–æ–∫ –∞–º–ø–ª—ñ—Ç—É–¥
        prob_up = np.cos(theta / 2) ** 2      
        prob_down = np.sin(theta / 2) ** 2    
        
        st.metric("–ô–º–æ–≤—ñ—Ä–Ω—ñ—Å—Ç—å –°–ø—ñ–Ω –í–ì–û–†–£ (‚Üë)", f"{prob_up * 100:.1f}%")
        st.metric("–ô–º–æ–≤—ñ—Ä–Ω—ñ—Å—Ç—å –°–ø—ñ–Ω –í–ù–ò–ó (‚Üì)", f"{prob_down * 100:.1f}%")
        
        # –§–æ—Ä–º—É–ª–∞
        st.latex(r"|\Psi\rangle = \cos\frac{\theta}{2}|0\rangle + e^{i\phi}\sin\frac{\theta}{2}|1\rangle")

    with col2:
        # --- 3D –í–Ü–ó–£–ê–õ–Ü–ó–ê–¶–Ü–Ø ---
        
        x = np.sin(theta) * np.cos(phi)
        y = np.sin(theta) * np.sin(phi)
        z = np.cos(theta)
        
        fig = go.Figure()
        
        # 1. –°—Ñ–µ—Ä–∞ (–ø—Ä–æ–∑–æ—Ä–∞)
        u = np.linspace(0, 2 * np.pi, 50)
        v = np.linspace(0, np.pi, 50)
        x_sphere = np.outer(np.cos(u), np.sin(v))
        y_sphere = np.outer(np.sin(u), np.sin(v))
        z_sphere = np.outer(np.ones(np.size(u)), np.cos(v))
        
        fig.add_trace(go.Surface(
            x=x_sphere, y=y_sphere, z=z_sphere,
            opacity=0.1,
            showscale=False,
            colorscale='Blues',
            hoverinfo='skip'
        ))
        
        # 2. –û—Å—ñ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç (–¢–æ–≤—Å—Ç—ñ –ª—ñ–Ω—ñ—ó)
        line_len = 1.1
        fig.add_trace(go.Scatter3d(x=[0, 0], y=[0, 0], z=[-line_len, line_len],
            mode='lines', line=dict(color='blue', width=5), name='Z'))
        fig.add_trace(go.Scatter3d(x=[-line_len, line_len], y=[0, 0], z=[0, 0],
            mode='lines', line=dict(color='green', width=5), name='X'))
        fig.add_trace(go.Scatter3d(x=[0, 0], y=[-line_len, line_len], z=[0, 0],
            mode='lines', line=dict(color='orange', width=5), name='Y'))
        
        # 3. –í–µ–∫—Ç–æ—Ä –°–ø—ñ–Ω–∞ (–Ø—Å–∫—Ä–∞–≤–æ-—á–µ—Ä–≤–æ–Ω–∏–π)
        fig.add_trace(go.Scatter3d(
            x=[0, x], y=[0, y], z=[0, z],
            mode='lines+markers',
            line=dict(color='red', width=10),     
            marker=dict(size=6, color='red'),    
            name='–í–µ–∫—Ç–æ—Ä –°–ø—ñ–Ω–∞'
        ))
        
        # 4. –¢–æ—á–∫–∞ –Ω–∞ –ø–æ–≤–µ—Ä—Ö–Ω—ñ
        fig.add_trace(go.Scatter3d(
            x=[x], y=[y], z=[z],
            mode='markers',
            marker=dict(size=12, color='red', symbol='diamond'),
            showlegend=False
        ))

        # 5. –¢–µ–∫—Å—Ç–æ–≤—ñ –ø—ñ–¥–ø–∏—Å–∏ –ø–æ–ª—é—Å—ñ–≤
        fig.add_trace(go.Scatter3d(
            x=[0, 0, 1.3, 0, 0, 0],
            y=[0, 0, 0, 1.3, 0, 0],
            z=[1.1, -1.1, 0, 0, 0, 0],
            mode='text',
            text=['|0‚ü© (‚Üë)', '|1‚ü© (‚Üì)', '+X', '+Y', '', ''],
            textposition="top center",
            showlegend=False
        ))

        # –ù–∞–ª–∞—à—Ç—É–≤–∞–Ω–Ω—è –∫–∞–º–µ—Ä–∏
        fig.update_layout(
            width=700, height=600,
            title="–Ü–Ω—Ç–µ—Ä–∞–∫—Ç–∏–≤–Ω–∞ –°—Ñ–µ—Ä–∞ –ë–ª–æ—Ö–∞",
            scene=dict(
                xaxis=dict(visible=False, showbackground=False),
                yaxis=dict(visible=False, showbackground=False),
                zaxis=dict(visible=False, showbackground=False),
                aspectmode='cube'
            ),
            margin=dict(l=0, r=0, b=0, t=30)
        )
        
        st.plotly_chart(fig, use_container_width=True)

if __name__ == "__main__":
    run_spin_visualization()

################ FILE: ./pages/2_Entanglement.py ################

import streamlit as st
import numpy as np
import matplotlib
matplotlib.use('Agg')
import matplotlib.pyplot as plt
import plotly.graph_objects as go
import time

st.set_page_config(page_title="–ö–≤–∞–Ω—Ç–æ–≤–∞ –ó–∞–ø–ª—É—Ç–∞–Ω—ñ—Å—Ç—å", layout="wide")

def create_starfield(n=200):
    """–ì–µ–Ω–µ—Ä—É—î –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∏ –∑—ñ—Ä–æ–∫ –¥–ª—è —Ñ–æ–Ω—É"""
    x = np.random.uniform(-200, 200, n)
    y = np.random.uniform(-100, 100, n)
    z = np.random.uniform(-100, 100, n)
    return x, y, z

def run_entanglement_simulation():
    st.title("üîó –ï–∫—Å–ø–µ—Ä–∏–º–µ–Ω—Ç–∏ –∑ –ö–≤–∞–Ω—Ç–æ–≤–æ—é –ó–∞–ø–ª—É—Ç–∞–Ω—ñ—Å—Ç—é")
    
    # –ì–æ–ª–æ–≤–Ω–µ –º–µ–Ω—é –≤–∏–±–æ—Ä—É —Å–∏–º—É–ª—è—Ü—ñ—ó
    sim_type = st.radio("–û–±–µ—Ä—ñ—Ç—å –µ–∫—Å–ø–µ—Ä–∏–º–µ–Ω—Ç:", 
        ["1. –í—ñ–∑—É–∞–ª—ñ–∑–∞—Ü—ñ—è –®—Ç–µ—Ä–Ω–∞-–ì–µ—Ä–ª–∞—Ö–∞ (3D –ê–Ω—ñ–º–∞—Ü—ñ—è)", 
         "2. –ï–∫—Å–ø–µ—Ä–∏–º–µ–Ω—Ç –ë–µ–ª–ª–∞ (–ì—Ä–∞—Ñ—ñ–∫ –∫–æ—Ä–µ–ª—è—Ü—ñ—ó)",
         "3. –ö–æ—Å–º—ñ—á–Ω–∏–π –ï–∫—Å–ø–µ—Ä–∏–º–µ–Ω—Ç (–ù–µ–ª–æ–∫–∞–ª—å–Ω—ñ—Å—Ç—å)"])

    st.divider()

# === 1. –í–Ü–ó–£–ê–õ–Ü–ó–ê–¶–Ü–Ø –®–¢–ï–†–ù–ê-–ì–ï–†–õ–ê–•–ê (–í–ò–ü–†–ê–í–õ–ï–ù–ê –¢–ê –ü–û–ö–†–ê–©–ï–ù–ê) ===
    if sim_type == "1. –í—ñ–∑—É–∞–ª—ñ–∑–∞—Ü—ñ—è –®—Ç–µ—Ä–Ω–∞-–ì–µ—Ä–ª–∞—Ö–∞ (3D –ê–Ω—ñ–º–∞—Ü—ñ—è)":
        st.header("1. –ï–∫—Å–ø–µ—Ä–∏–º–µ–Ω—Ç –®—Ç–µ—Ä–Ω–∞-–ì–µ—Ä–ª–∞—Ö–∞")
        st.markdown("**–°—É—Ç—å:** –†–æ–∑—â–µ–ø–ª–µ–Ω–Ω—è –ø—É—á–∫–∞ –∑–∞–ø–ª—É—Ç–∞–Ω–∏—Ö –µ–ª–µ–∫—Ç—Ä–æ–Ω—ñ–≤ —É –º–∞–≥–Ω—ñ—Ç–Ω–æ–º—É –ø–æ–ª—ñ.")
        
        col1, col2 = st.columns([3, 1])
        
        with col2:
            st.markdown("### üéÆ –ö–µ—Ä—É–≤–∞–Ω–Ω—è")
            if st.button("üî¥ –ì–µ–Ω–µ—Ä—É–≤–∞—Ç–∏ –Ω–æ–≤—É –ø–∞—Ä—É", type="primary"):
                st.session_state['run_sg'] = True
                st.session_state['outcome_sg'] = np.random.choice([0, 1])
            
            st.markdown("---")
            st.info("–ù–∞—Ç–∏—Å–Ω—ñ—Ç—å –∫–Ω–æ–ø–∫—É, —â–æ–± —Å—Ç–≤–æ—Ä–∏—Ç–∏ –Ω–æ–≤—É –ø–∞—Ä—É –µ–ª–µ–∫—Ç—Ä–æ–Ω—ñ–≤.")

        with col1:
            if 'outcome_sg' not in st.session_state:
                st.session_state['outcome_sg'] = 0
                
            outcome = st.session_state['outcome_sg']
            steps = 50
            x_left = np.linspace(0, -6, steps)
            x_right = np.linspace(0, 6, steps)
            y_path = np.zeros(steps)
            z_left = np.zeros(steps)
            z_right = np.zeros(steps)
            
            mag_start = int(steps * 0.33)
            t_def = np.linspace(0, 1, steps - mag_start)
            deflection = 1.5 * t_def**2
            
            if outcome == 0: 
                z_left[mag_start:] = deflection
                z_right[mag_start:] = -deflection
                res_text = "–†–µ–∑—É–ª—å—Ç–∞—Ç: –õ—ñ–≤–∏–π ‚¨Ü (S), –ü—Ä–∞–≤–∏–π ‚¨á (N)"
                c_l, c_r = 'red', 'blue'
                spin_L, spin_R = "‚Üë", "‚Üì"
            else:
                z_left[mag_start:] = -deflection
                z_right[mag_start:] = deflection
                res_text = "–†–µ–∑—É–ª—å—Ç–∞—Ç: –õ—ñ–≤–∏–π ‚¨á (N), –ü—Ä–∞–≤–∏–π ‚¨Ü (S)"
                c_l, c_r = 'blue', 'red'
                spin_L, spin_R = "‚Üì", "‚Üë"

            fig = go.Figure()

            # 1. –î–∂–µ—Ä–µ–ª–æ
            fig.add_trace(go.Scatter3d(x=[0], y=[0], z=[0], mode='markers', marker=dict(size=15, color='purple'), name='–î–∂–µ—Ä–µ–ª–æ'))
            
            # 2. –¢—Ä–∞—î–∫—Ç–æ—Ä—ñ—ó (–ü—É–Ω–∫—Ç–∏—Ä)
            fig.add_trace(go.Scatter3d(x=x_left, y=y_path, z=z_left, mode='lines', line=dict(color='gray', width=4, dash='dot'), name='–®–ª—è—Ö L'))
            fig.add_trace(go.Scatter3d(x=x_right, y=y_path, z=z_right, mode='lines', line=dict(color='gray', width=4, dash='dot'), name='–®–ª—è—Ö R'))

            # 3. –ú–∞–≥–Ω—ñ—Ç–∏
            # –õ—ñ–≤–∏–π
            fig.add_trace(go.Mesh3d(x=[-3,-3,-2,-2, -3,-3,-2,-2], y=[-1,1,1,-1, -1,1,1,-1], z=[1,1,1,1, 2,2,2,2], color='gray', opacity=0.3, name='L-Mag Top'))
            fig.add_trace(go.Mesh3d(x=[-3,-3,-2,-2, -3,-3,-2,-2], y=[-1,1,1,-1, -1,1,1,-1], z=[-2,-2,-2,-2, -1,-1,-1,-1], color='gray', opacity=0.3, name='L-Mag Bot'))
            # –ü—Ä–∞–≤–∏–π
            fig.add_trace(go.Mesh3d(x=[2,2,3,3, 2,2,3,3], y=[-1,1,1,-1, -1,1,1,-1], z=[1,1,1,1, 2,2,2,2], color='gray', opacity=0.3, name='R-Mag Top'))
            fig.add_trace(go.Mesh3d(x=[2,2,3,3, 2,2,3,3], y=[-1,1,1,-1, -1,1,1,-1], z=[-2,-2,-2,-2, -1,-1,-1,-1], color='gray', opacity=0.3, name='R-Mag Bot'))
            
            # –ü—ñ–¥–ø–∏—Å–∏
            fig.add_trace(go.Scatter3d(x=[-2.5, -2.5, 2.5, 2.5], y=[0,0,0,0], z=[1.2, -1.2, 1.2, -1.2], mode='text', text=['S', 'N', 'S', 'N'], textfont=dict(size=15, color='black'), showlegend=False))

            # 4. –ü–æ—á–∞—Ç–∫–æ–≤—ñ –µ–ª–µ–∫—Ç—Ä–æ–Ω–∏
            fig.add_trace(go.Scatter3d(x=[0], y=[0], z=[0], mode='markers', marker=dict(color=c_l, size=10), name='–ï–ª–µ–∫—Ç—Ä–æ–Ω L'))
            fig.add_trace(go.Scatter3d(x=[0], y=[0], z=[0], mode='markers', marker=dict(color=c_r, size=10), name='–ï–ª–µ–∫—Ç—Ä–æ–Ω R'))

            # –ê–Ω—ñ–º–∞—Ü—ñ—è
            frames = []
            for i in range(0, steps, 1):
                frames.append(go.Frame(data=[
                    go.Scatter3d(x=[x_left[i]], y=[0], z=[z_left[i]], mode='markers', marker=dict(color=c_l, size=10)),
                    go.Scatter3d(x=[x_right[i]], y=[0], z=[z_right[i]], mode='markers', marker=dict(color=c_r, size=10))
                ]))

            fig.update_layout(
                width=800, height=500, 
                scene=dict(xaxis=dict(title='–í—ñ—Å—å –ø—É—á–∫–∞', range=[-6.5, 6.5]), yaxis=dict(visible=False, range=[-2, 2]), zaxis=dict(title='–í—ñ–¥—Ö–∏–ª–µ–Ω–Ω—è', range=[-3, 3]), aspectmode='manual', aspectratio=dict(x=3, y=1, z=1)),
                updatemenus=[dict(type="buttons", showactive=False, buttons=[dict(label="‚ñ∂Ô∏è –°—Ç–∞—Ä—Ç", method="animate", args=[None, dict(frame=dict(duration=30, redraw=True), fromcurrent=True)])])]
            )
            fig.frames = frames
            st.plotly_chart(fig)
            
            if st.session_state.get('run_sg'):
                st.success(f"**{res_text}**")

        # --- –î–ï–¢–ê–õ–¨–ù–ò–ô –û–ü–ò–° (–®–¢–ï–†–ù-–ì–ï–†–õ–ê–•) ---
        st.markdown("---")
        st.markdown("### üìö –î–µ—Ç–∞–ª—å–Ω–µ –ø–æ—è—Å–Ω–µ–Ω–Ω—è –µ–∫—Å–ø–µ—Ä–∏–º–µ–Ω—Ç—É")
        st.markdown(r"""
        **–Ü—Å—Ç–æ—Ä–∏—á–Ω–∏–π –∫–æ–Ω—Ç–µ–∫—Å—Ç:**
        –ï–∫—Å–ø–µ—Ä–∏–º–µ–Ω—Ç, –ø—Ä–æ–≤–µ–¥–µ–Ω–∏–π –û—Ç—Ç–æ –®—Ç–µ—Ä–Ω–æ–º —ñ –í–∞–ª—å—Ç–µ—Ä–æ–º –ì–µ—Ä–ª–∞—Ö–æ–º —É 1922 —Ä–æ—Ü—ñ, —Å—Ç–∞–≤ —Ñ—É–Ω–¥–∞–º–µ–Ω—Ç–∞–ª—å–Ω–∏–º –¥–æ–∫–∞–∑–æ–º –∫–≤–∞–Ω—Ç—É–≤–∞–Ω–Ω—è –º–æ–º–µ–Ω—Ç—É —ñ–º–ø—É–ª—å—Å—É. –í–æ–Ω–∏ –ø—Ä–æ–ø—É—Å–∫–∞–ª–∏ –ø—É—á–æ–∫ –∞—Ç–æ–º—ñ–≤ —Å—Ä—ñ–±–ª–∞ —á–µ—Ä–µ–∑ —Å–∏–ª—å–Ω–µ –Ω–µ–æ–¥–Ω–æ—Ä—ñ–¥–Ω–µ –º–∞–≥–Ω—ñ—Ç–Ω–µ –ø–æ–ª–µ.

        **–§—ñ–∑–∏–∫–∞ –ø—Ä–æ—Ü–µ—Å—É:**
        1.  **–°–ø—ñ–Ω —è–∫ –º–∞–≥–Ω—ñ—Ç:** –ï–ª–µ–∫—Ç—Ä–æ–Ω (–∞–±–æ –∞—Ç–æ–º —Å—Ä—ñ–±–ª–∞) –º–∞—î –≤–ª–∞—Å–Ω–∏–π –º–æ–º–µ–Ω—Ç —ñ–º–ø—É–ª—å—Å—É ‚Äî —Å–ø—ñ–Ω. –¶–µ –ø–µ—Ä–µ—Ç–≤–æ—Ä—é—î —á–∞—Å—Ç–∏–Ω–∫—É –Ω–∞ –∫—Ä–∏—Ö—ñ—Ç–Ω–∏–π –º–∞–≥–Ω—ñ—Ç —ñ–∑ –º–∞–≥–Ω—ñ—Ç–Ω–∏–º –º–æ–º–µ–Ω—Ç–æ–º $\mu$.
        2.  **–ù–µ–æ–¥–Ω–æ—Ä—ñ–¥–Ω–µ –ø–æ–ª–µ:** –ú–∞–≥–Ω—ñ—Ç–∏ —Å–ø–µ—Ü—ñ–∞–ª—å–Ω–æ—ó —Ñ–æ—Ä–º–∏ —Å—Ç–≤–æ—Ä—é—é—Ç—å –ø–æ–ª–µ, —è–∫–µ —Å–∏–ª—å–Ω—ñ—à–µ –≤ –æ–¥–Ω—ñ–π —Ç–æ—á—Ü—ñ –ø—Ä–æ—Å—Ç–æ—Ä—É —ñ —Å–ª–∞–±—à–µ –≤ —ñ–Ω—à—ñ–π (–≥—Ä–∞–¥—ñ—î–Ω—Ç –ø–æ–ª—è $\partial B / \partial z$).
        3.  **–°–∏–ª–∞ –≤–∑–∞—î–º–æ–¥—ñ—ó:** –ù–∞ –º–∞–≥–Ω—ñ—Ç–Ω–∏–π –¥–∏–ø–æ–ª—å —É –Ω–µ–æ–¥–Ω–æ—Ä—ñ–¥–Ω–æ–º—É –ø–æ–ª—ñ –¥—ñ—î —Å–∏–ª–∞:
            $$ F_z = \mu_z \frac{\partial B}{\partial z} $$
        4.  **–ö–≤–∞–Ω—Ç—É–≤–∞–Ω–Ω—è:** –£ –∫–ª–∞—Å–∏—á–Ω—ñ–π —Ñ—ñ–∑–∏—Ü—ñ —Å—Ç—Ä—ñ–ª–∫–∞ –º–∞–≥–Ω—ñ—Ç—É –º–æ–∂–µ –±—É—Ç–∏ –ø–æ–≤–µ—Ä–Ω—É—Ç–∞ –ø—ñ–¥ –±—É–¥—å-—è–∫–∏–º –∫—É—Ç–æ–º, —Ç–æ–º—É –º–∏ –æ—á—ñ–∫—É–≤–∞–ª–∏ –± –ø–æ–±–∞—á–∏—Ç–∏ —Å—É—Ü—ñ–ª—å–Ω—É —Å–º—É–≥—É –∞—Ç–æ–º—ñ–≤ –Ω–∞ –µ–∫—Ä–∞–Ω—ñ. –ê–ª–µ —É –∫–≤–∞–Ω—Ç–æ–≤—ñ–π –º–µ—Ö–∞–Ω—ñ—Ü—ñ –ø—Ä–æ–µ–∫—Ü—ñ—è —Å–ø—ñ–Ω–∞ –Ω–∞ –≤—ñ—Å—å Z –º–æ–∂–µ –ø—Ä–∏–π–º–∞—Ç–∏ –ª–∏—à–µ –¥–≤–∞ –∑–Ω–∞—á–µ–Ω–Ω—è: $+\hbar/2$ (–≤–≥–æ—Ä—É) –∞–±–æ $-\hbar/2$ (–≤–Ω–∏–∑).
        
        **–ß–æ–º—É –∑–∞–ø–ª—É—Ç–∞–Ω—ñ—Å—Ç—å?**
        –£ –Ω–∞—à—ñ–π —Å–∏–º—É–ª—è—Ü—ñ—ó –º–∏ —Ä–æ–∑–≥–ª—è–¥–∞—î–º–æ –ø–∞—Ä—É –µ–ª–µ–∫—Ç—Ä–æ–Ω—ñ–≤ —É **—Å–∏–Ω–≥–ª–µ—Ç–Ω–æ–º—É —Å—Ç–∞–Ω—ñ**. –¶–µ –æ–∑–Ω–∞—á–∞—î, —â–æ —ó—Ö–Ω—ñ–π —Å—É–º–∞—Ä–Ω–∏–π —Å–ø—ñ–Ω –¥–æ—Ä—ñ–≤–Ω—é—î –Ω—É–ª—é. 
        $$ |\Psi\rangle = \frac{1}{\sqrt{2}} (| \uparrow \rangle_1 | \downarrow \rangle_2 - | \downarrow \rangle_1 | \uparrow \rangle_2) $$
        –¶–µ —Å—Ç–≤–æ—Ä—é—î –∂–æ—Ä—Å—Ç–∫—É –∫–æ—Ä–µ–ª—è—Ü—ñ—é: —è–∫—â–æ –æ–¥–∏–Ω –µ–ª–µ–∫—Ç—Ä–æ–Ω –≤—ñ–¥—Ö–∏–ª—è—î—Ç—å—Å—è –≤–≥–æ—Ä—É, —ñ–Ω—à–∏–π **–æ–±–æ–≤'—è–∑–∫–æ–≤–æ** –≤—ñ–¥—Ö–∏–ª—è—î—Ç—å—Å—è –≤–Ω–∏–∑, —â–æ–± –∑–±–µ—Ä–µ–≥—Ç–∏ –∑–∞–∫–æ–Ω –∑–±–µ—Ä–µ–∂–µ–Ω–Ω—è –º–æ–º–µ–Ω—Ç—É —ñ–º–ø—É–ª—å—Å—É. –¶–µ –≤—ñ–¥–±—É–≤–∞—î—Ç—å—Å—è –º–∏—Ç—Ç—î–≤–æ —ñ —É–∑–≥–æ–¥–∂–µ–Ω–æ, —â–æ —ñ –¥–µ–º–æ–Ω—Å—Ç—Ä—É—î –∞–Ω—ñ–º–∞—Ü—ñ—è.
        """)

    # =============================================================================
    # 2. –ù–ï–†–Ü–í–ù–Ü–°–¢–¨ –ë–ï–õ–õ–ê
    # =============================================================================
    elif sim_type == "2. –ï–∫—Å–ø–µ—Ä–∏–º–µ–Ω—Ç –ë–µ–ª–ª–∞ (–ì—Ä–∞—Ñ—ñ–∫ –∫–æ—Ä–µ–ª—è—Ü—ñ—ó)":
        st.header("2. –ü–µ—Ä–µ–≤—ñ—Ä–∫–∞ –ù–µ—Ä—ñ–≤–Ω–æ—Å—Ç—ñ –ë–µ–ª–ª–∞")
        
        c1, c2 = st.columns([1, 1])
        with c1:
            st.subheader("üõ† –ù–∞–ª–∞—à—Ç—É–≤–∞–Ω–Ω—è")
            a = st.slider("–ö—É—Ç –¥–µ—Ç–µ–∫—Ç–æ—Ä–∞ –ê (Œ±)", 0, 360, 0, 15)
            b = st.slider("–ö—É—Ç –¥–µ—Ç–µ–∫—Ç–æ—Ä–∞ –ë (Œ≤)", 0, 360, 45, 15)
            theta = abs(a - b)
            st.info(f"–†—ñ–∑–Ω–∏—Ü—è: {theta}¬∞")
        
        with c2:
            st.subheader("üé≤ –°–∏–º—É–ª—è—Ü—ñ—è")
            # –°–ª–∞–π–¥–µ—Ä –∑ –∫—Ä–æ–∫–æ–º 100
            n = st.slider("–ö—ñ–ª—å–∫—ñ—Å—Ç—å –≤–∏–º—ñ—Ä—é–≤–∞–Ω—å", 100, 10000, 1000, step=100)
            
            if st.button("–ó–∞–ø—É—Å—Ç–∏—Ç–∏ –µ–∫—Å–ø–µ—Ä–∏–º–µ–Ω—Ç", type="primary"):
                rad = np.radians(theta)
                # –ô–º–æ–≤—ñ—Ä–Ω—ñ—Å—Ç—å —Ä—ñ–∑–Ω–∏—Ö —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ñ–≤
                p_diff = np.cos(rad/2)**2
                rv = np.random.random(n)
                diff = np.sum(rv < p_diff)
                same = n - diff
                # –ö–æ—Ä–µ–ª—è—Ü—ñ—è
                corr = (same - diff) / n
                
                fig, ax = plt.subplots(figsize=(6, 3))
                ang = np.linspace(0, 360, 100)
                ax.plot(ang, -np.cos(np.radians(ang)), 'k--', label='–ö–≤–∞–Ω—Ç–æ–≤–∞ —Ç–µ–æ—Ä—ñ—è')
                ax.plot([theta], [corr], 'ro', label='–ï–∫—Å–ø–µ—Ä–∏–º–µ–Ω—Ç')
                ax.set_xlabel("–†—ñ–∑–Ω–∏—Ü—è –∫—É—Ç—ñ–≤")
                ax.set_ylabel("–ö–æ—Ä–µ–ª—è—Ü—ñ—è")
                ax.legend()
                st.pyplot(fig)
        
        # --- –î–ï–¢–ê–õ–¨–ù–ï –ü–û–Ø–°–ù–ï–ù–ù–Ø (–ë–ï–õ–õ) ---
        st.markdown("---")
        st.markdown("### üìö –ü–æ—è—Å–Ω–µ–Ω–Ω—è –ù–µ—Ä—ñ–≤–Ω–æ—Å—Ç—ñ –ë–µ–ª–ª–∞")
        st.markdown(r"""
        **–ü—Ä–æ–±–ª–µ–º–∞ –ï–π–Ω—à—Ç–µ–π–Ω–∞-–ü–æ–¥–æ–ª—å—Å—å–∫–æ–≥–æ-–†–æ–∑–µ–Ω–∞ (EPR):**
        –ê–ª—å–±–µ—Ä—Ç –ï–π–Ω—à—Ç–µ–π–Ω –Ω–µ –≤—ñ—Ä–∏–≤, —â–æ –∫–≤–∞–Ω—Ç–æ–≤–∞ –º–µ—Ö–∞–Ω—ñ–∫–∞ –ø–æ–≤–Ω–∞. –í—ñ–Ω –≤–≤–∞–∂–∞–≤, —â–æ "–ë–æ–≥ –Ω–µ –≥—Ä–∞—î –≤ –∫–æ—Å—Ç—ñ", —ñ —â–æ —É —á–∞—Å—Ç–∏–Ω–æ–∫ —î **–ø—Ä–∏—Ö–æ–≤–∞–Ω—ñ –ø–∞—Ä–∞–º–µ—Ç—Ä–∏** ‚Äî —ñ–Ω—Å—Ç—Ä—É–∫—Ü—ñ—ó, —è–∫—ñ –≤–∏–∑–Ω–∞—á–∞—é—Ç—å —Ä–µ–∑—É–ª—å—Ç–∞—Ç –≤–∏–º—ñ—Ä—é–≤–∞–Ω–Ω—è –∑–∞–∑–¥–∞–ª–µ–≥—ñ–¥—å, —â–µ –¥–æ –º–æ–º–µ–Ω—Ç—É –≤–∏–º—ñ—Ä—é–≤–∞–Ω–Ω—è. –¶—è –∫–æ–Ω—Ü–µ–ø—Ü—ñ—è –Ω–∞–∑–∏–≤–∞—î—Ç—å—Å—è **–ª–æ–∫–∞–ª—å–Ω–∏–º —Ä–µ–∞–ª—ñ–∑–º–æ–º**.

        **–¢–µ–æ—Ä–µ–º–∞ –ë–µ–ª–ª–∞:**
        –£ 1964 —Ä–æ—Ü—ñ –î–∂–æ–Ω –ë–µ–ª–ª –¥–æ–≤—ñ–≤, —â–æ —è–∫—â–æ –ª–æ–∫–∞–ª—å–Ω–∏–π —Ä–µ–∞–ª—ñ–∑–º –ø—Ä–∞–≤–∏–ª—å–Ω–∏–π, —Ç–æ –∫–æ—Ä–µ–ª—è—Ü—ñ—è –º—ñ–∂ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞–º–∏ –≤–∏–º—ñ—Ä—é–≤–∞–Ω—å –¥–≤–æ—Ö —á–∞—Å—Ç–∏–Ω–æ–∫ –Ω–µ –º–æ–∂–µ –ø–µ—Ä–µ–≤–∏—â—É–≤–∞—Ç–∏ –ø–µ–≤–Ω—É –º–µ–∂—É (–ª—ñ–Ω—ñ–π–Ω–∞ –∑–∞–ª–µ–∂–Ω—ñ—Å—Ç—å –≤—ñ–¥ –∫—É—Ç–∞).
        
        * **–ö–ª–∞—Å–∏—á–Ω–µ –ø–µ—Ä–µ–¥–±–∞—á–µ–Ω–Ω—è:** –ì—Ä–∞—Ñ—ñ–∫ –∫–æ—Ä–µ–ª—è—Ü—ñ—ó –º–∞–≤ –±–∏ –±—É—Ç–∏ –ø—Ä—è–º–∏–º–∏ –ª—ñ–Ω—ñ—è–º–∏ (—Ç—Ä–∏–∫—É—Ç–Ω–∞ —Ñ–æ—Ä–º–∞).
        * **–ö–≤–∞–Ω—Ç–æ–≤–µ –ø–µ—Ä–µ–¥–±–∞—á–µ–Ω–Ω—è:** –ì—Ä–∞—Ñ—ñ–∫ –∫–æ—Ä–µ–ª—è—Ü—ñ—ó ‚Äî —Ü–µ –∫–æ—Å–∏–Ω—É—Å–æ—ó–¥–∞ ($E = -\cos(\theta)$).

        **–†–µ–∑—É–ª—å—Ç–∞—Ç —Å–∏–º—É–ª—è—Ü—ñ—ó:**
        –Ø–∫ –≤–∏ –±–∞—á–∏—Ç–µ –Ω–∞ –≥—Ä–∞—Ñ—ñ–∫—É, —á–µ—Ä–≤–æ–Ω–∞ —Ç–æ—á–∫–∞ (–≤–∞—à –µ–∫—Å–ø–µ—Ä–∏–º–µ–Ω—Ç) –ª—è–≥–∞—î —Ç–æ—á–Ω–æ –Ω–∞ –ø—É–Ω–∫—Ç–∏—Ä–Ω—É –ª—ñ–Ω—ñ—é –∫–æ—Å–∏–Ω—É—Å–∞. –£ –ø–µ–≤–Ω–∏—Ö —Ç–æ—á–∫–∞—Ö (–Ω–∞–ø—Ä–∏–∫–ª–∞–¥, 45 –≥—Ä–∞–¥—É—Å—ñ–≤) –∫–≤–∞–Ω—Ç–æ–≤–∞ –∫–æ—Ä–µ–ª—è—Ü—ñ—è **—Å–∏–ª—å–Ω—ñ—à–∞**, –Ω—ñ–∂ —Ü–µ –º–∞—Ç–µ–º–∞—Ç–∏—á–Ω–æ –º–æ–∂–ª–∏–≤–æ –¥–ª—è –±—É–¥—å-—è–∫–æ—ó –∫–ª–∞—Å–∏—á–Ω–æ—ó —Å–∏—Å—Ç–µ–º–∏ –∑ –ø—Ä–∏—Ö–æ–≤–∞–Ω–∏–º–∏ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞–º–∏.

        **–í–∏—Å–Ω–æ–≤–æ–∫:**
        –¶–µ –¥–æ–≤–æ–¥–∏—Ç—å, —â–æ **–ª–æ–∫–∞–ª—å–Ω–æ–≥–æ —Ä–µ–∞–ª—ñ–∑–º—É –Ω–µ —ñ—Å–Ω—É—î**. –ß–∞—Å—Ç–∏–Ω–∫–∏ –Ω–µ –º–∞—é—Ç—å –∑–∞–∑–¥–∞–ª–µ–≥—ñ–¥—å –≤–∏–∑–Ω–∞—á–µ–Ω–æ–≥–æ —Å—Ç–∞–Ω—É, –ø–æ–∫–∏ —ó—Ö –Ω–µ –≤–∏–º—ñ—Ä—è—é—Ç—å. –í–∏–º—ñ—Ä—é–≤–∞–Ω–Ω—è –æ–¥–Ω—ñ—î—ó —á–∞—Å—Ç–∏–Ω–∫–∏ **–º–∏—Ç—Ç—î–≤–æ** —Ñ–æ—Ä–º—É—î —Ä–µ–∞–ª—å–Ω—ñ—Å—Ç—å –¥–ª—è —ñ–Ω—à–æ—ó, –Ω–µ–∑–∞–ª–µ–∂–Ω–æ –≤—ñ–¥ –≤—ñ–¥—Å—Ç–∞–Ω—ñ.
        """)

    # =============================================================================
    # 3. –ö–û–°–ú–Ü–ß–ù–ò–ô –ï–ö–°–ü–ï–†–ò–ú–ï–ù–¢ (–ù–û–í–ò–ô –Ü–ù–¢–ï–†–§–ï–ô–°)
    # =============================================================================
    elif sim_type == "3. –ö–æ—Å–º—ñ—á–Ω–∏–π –ï–∫—Å–ø–µ—Ä–∏–º–µ–Ω—Ç (–ù–µ–ª–æ–∫–∞–ª—å–Ω—ñ—Å—Ç—å)":
        st.header("3. –ö–æ—Å–º—ñ—á–Ω–∞ –ù–µ–ª–æ–∫–∞–ª—å–Ω—ñ—Å—Ç—å")
        
        st.markdown("""
        –¶—è —Å–∏–º—É–ª—è—Ü—ñ—è –¥–µ–º–æ–Ω—Å—Ç—Ä—É—î –ø–∞—Ä–∞–¥–æ–∫—Å –º–∏—Ç—Ç—î–≤–æ—ó –¥—ñ—ó. 
        –ú–∏ —Ä–æ–∑–Ω–µ—Å–ª–∏ –ª–∞–±–æ—Ä–∞—Ç–æ—Ä—ñ—ó –Ω–∞ –∞—Å—Ç—Ä–æ–Ω–æ–º—ñ—á–Ω—É –≤—ñ–¥—Å—Ç–∞–Ω—å. –°–≤—ñ—Ç–ª–æ–≤–∏–π —Å–∏–≥–Ω–∞–ª (–∂–æ–≤—Ç–∞ —Ç–æ—á–∫–∞) –ø–æ–∫–∞–∑—É—î –æ–±–º–µ–∂–µ–Ω–Ω—è —à–≤–∏–¥–∫–æ—Å—Ç—ñ —É –í—Å–µ—Å–≤—ñ—Ç—ñ ($c$), —Ç–æ–¥—ñ —è–∫ –∫–≤–∞–Ω—Ç–æ–≤–∏–π —Å—Ç–∞–Ω –∑–º—ñ–Ω—é—î—Ç—å—Å—è –º–∏—Ç—Ç—î–≤–æ.
        """)

        # --- –Ü–ù–¢–ï–†–§–ï–ô–° –Ø–ö –ù–ê –°–ö–†–Ü–ù–®–û–¢–Ü ---
        col1, col2 = st.columns([1.5, 2.5])

        with col1:
            st.info("–ù–∞—Ç–∏—Å–Ω—ñ—Ç—å –∫–Ω–æ–ø–∫—É, —â–æ–± –≤–∏–º—ñ—Ä—è—Ç–∏ —Å–ø—ñ–Ω –Ω–∞ –ó–µ–º–ª—ñ.")
            
            # –ö–Ω–æ–ø–∫–∏ –∫–µ—Ä—É–≤–∞–Ω–Ω—è
            if st.button("üî¥ –í–ò–ú–Ü–†–Ø–¢–ò –°–ü–Ü–ù (–ê–ª—ñ—Å–∞)", type="primary"):
                st.session_state['cosmic_measured'] = True
                st.session_state['cosmic_outcome'] = np.random.choice([1, -1])
                st.session_state['show_animation'] = False 

            if st.button("üîÑ –°–∫–∏–Ω—É—Ç–∏ –µ–∫—Å–ø–µ—Ä–∏–º–µ–Ω—Ç"):
                st.session_state['cosmic_measured'] = False
                st.session_state['show_animation'] = False
                st.rerun()
            
            st.markdown("---")

            # –ë–ª–æ–∫–∏ —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ñ–≤ (–∑'—è–≤–ª—è—é—Ç—å—Å—è –ø—ñ—Å–ª—è –≤–∏–º—ñ—Ä—é–≤–∞–Ω–Ω—è)
            if st.session_state.get('cosmic_measured'):
                outcome = st.session_state['cosmic_outcome']
                # –õ–æ–≥—ñ–∫–∞: —è–∫—â–æ –ó–µ–º–ª—è +1 (–í–≥–æ—Ä—É), —Ç–æ –ê–Ω–¥—Ä–æ–º–µ–¥–∞ -1 (–í–Ω–∏–∑)
                txt_earth = "–í–ì–û–†–£ (‚Üë)" if outcome == 1 else "–í–ù–ò–ó (‚Üì)"
                txt_andromeda = "–í–ù–ò–ó (‚Üì)" if outcome == 1 else "–í–ì–û–†–£ (‚Üë)"
                
                st.success(f"üåç –ó–µ–º–ª—è: {txt_earth}")
                st.warning(f"üåå –ê–Ω–¥—Ä–æ–º–µ–¥–∞: {txt_andromeda}")
                st.error("‚è± –ß–∞—Å –ø–µ—Ä–µ–¥–∞—á—ñ —Å—Ç–∞–Ω—É: 0.00 —Å (–ú–∏—Ç—Ç—î–≤–æ!)")
                st.caption("–°–≤—ñ—Ç–ª–æ –∑–∞ —Ü–µ–π —á–∞—Å –ø—Ä–æ–π—à–ª–æ –± –º—ñ–∑–µ—Ä–Ω—É –≤—ñ–¥—Å—Ç–∞–Ω—å.")
                
                # –ö–Ω–æ–ø–∫–∞ –¥–ª—è –∑–∞–ø—É—Å–∫—É –∞–Ω—ñ–º–∞—Ü—ñ—ó (—è–∫ –Ω–∞ —Å–∫—Ä—ñ–Ω—à–æ—Ç—ñ "–î–∏–≤–∏—Ç–∏—Å—å —Ä–µ–∑—É–ª—å—Ç–∞—Ç")
                if st.button("‚ñ∂Ô∏è –î–∏–≤–∏—Ç–∏—Å—å –†–µ–∑—É–ª—å—Ç–∞—Ç (–ê–Ω—ñ–º–∞—Ü—ñ—è)"):
                    st.session_state['show_animation'] = True

        with col2:
            # --- –õ–û–ì–Ü–ö–ê 3D –ê–ù–Ü–ú–ê–¶–Ü–á ---
            
            # –ö–æ–æ—Ä–¥–∏–Ω–∞—Ç–∏
            pos_Earth = [-80, 0, 0]
            pos_Andromeda = [80, 0, 0]
            
            fig = go.Figure()

            # 1. –§–æ–Ω (–ó—ñ—Ä–∫–∏)
            sx, sy, sz = create_starfield(300)
            fig.add_trace(go.Scatter3d(x=sx, y=sy, z=sz, mode='markers', marker=dict(size=1, color='white', opacity=0.6), hoverinfo='none'))

            # 2. –ü–ª–∞–Ω–µ—Ç–∏
            fig.add_trace(go.Scatter3d(x=[pos_Earth[0]], y=[0], z=[0], mode='markers+text', marker=dict(size=25, color='blue'), text=["üåç –ó–ï–ú–õ–Ø"], textposition="top center", name="–ó–µ–º–ª—è"))
            fig.add_trace(go.Scatter3d(x=[pos_Andromeda[0]], y=[0], z=[0], mode='markers+text', marker=dict(size=35, color='purple'), text=["üåå –ê–ù–î–†–û–ú–ï–î–ê"], textposition="top center", name="–ê–Ω–¥—Ä–æ–º–µ–¥–∞"))
            
            # 3. –õ—ñ–Ω—ñ—è –∑–≤'—è–∑–∫—É
            fig.add_trace(go.Scatter3d(x=[-80, 80], y=[0,0], z=[0,0], mode='lines', line=dict(color='gray', width=1, dash='dash'), hoverinfo='none'))

            # –ê–Ω—ñ–º–∞—Ü—ñ—è –∑–∞–ø—É—Å–∫–∞—î—Ç—å—Å—è —Ç—ñ–ª—å–∫–∏ —è–∫—â–æ –Ω–∞—Ç–∏—Å–Ω—É—Ç–∞ –∫–Ω–æ–ø–∫–∞ –ø–µ—Ä–µ–≥–ª—è–¥—É
            if st.session_state.get('show_animation') and st.session_state.get('cosmic_measured'):
                outcome = st.session_state['cosmic_outcome']
                frames = []
                n_frames = 60
                collapse_frame = 10 

                for i in range(n_frames):
                    # –°–≤—ñ—Ç–ª–æ (–∂–æ–≤—Ç–µ)
                    light_x = -80 + (i / n_frames) * 50 # –ü—Ä–æ–ª–µ—Ç–∏—Ç—å –ª–∏—à–µ —Ç—Ä–æ—Ö–∏
                    
                    if i < collapse_frame:
                        # –î–æ –≤–∏–º—ñ—Ä—é–≤–∞–Ω–Ω—è (–ø—É–ª—å—Å–∞—Ü—ñ—è)
                        col_A = 'white'; col_B = 'white'
                        vec_A = 0; vec_B = 0
                    else:
                        # –ü—ñ—Å–ª—è –≤–∏–º—ñ—Ä—é–≤–∞–Ω–Ω—è (–≤–µ–∫—Ç–æ—Ä–∏)
                        growth = min(1.0, (i - collapse_frame) / 5.0)
                        scale = 30 * growth
                        vec_A = scale * outcome
                        vec_B = -scale * outcome
                        col_A = '#00FF00'; col_B = '#FF00FF' # –ó–µ–ª–µ–Ω–∏–π —ñ –ú–∞–ª–∏–Ω–æ–≤–∏–π

                    frames.append(go.Frame(data=[
                        go.Scatter3d(x=sx, y=sy, z=sz, mode='markers', marker=dict(size=1, color='white', opacity=0.6)), # –§–æ–Ω
                        go.Scatter3d(x=[pos_Earth[0]], y=[0], z=[0], mode='markers+text', marker=dict(size=25, color='blue'), text=["üåç"]), # –ó–µ–º–ª—è
                        go.Scatter3d(x=[pos_Andromeda[0]], y=[0], z=[0], mode='markers+text', marker=dict(size=35, color='purple'), text=["üåå"]), # –ê–Ω–¥—Ä–æ–º–µ–¥–∞
                        go.Scatter3d(x=[-80, 80], y=[0,0], z=[0,0], mode='lines', line=dict(color='gray', width=1, dash='dash')), # –õ—ñ–Ω—ñ—è
                        
                        # –°–≤—ñ—Ç–ª–æ
                        go.Scatter3d(x=[light_x], y=[0], z=[0], mode='markers', marker=dict(size=6, color='yellow'), name="–°–≤—ñ—Ç–ª–æ"),
                        # –°–ø—ñ–Ω –ê
                        go.Scatter3d(x=[-80,-80], y=[0,0], z=[0, vec_A], mode='lines+markers', line=dict(color=col_A, width=10), marker=dict(size=0), name="–°–ø—ñ–Ω –ê"),
                        # –°–ø—ñ–Ω –ë
                        go.Scatter3d(x=[80,80], y=[0,0], z=[0, vec_B], mode='lines+markers', line=dict(color=col_B, width=10), marker=dict(size=0), name="–°–ø—ñ–Ω –ë"),
                    ]))
                
                # –ü–æ—á–∞—Ç–∫–æ–≤–∏–π —Å—Ç–∞–Ω
                fig.add_trace(go.Scatter3d(x=[-80], y=[0], z=[0], mode='markers', marker=dict(size=6, color='yellow'), name="–°–≤—ñ—Ç–ª–æ"))
                fig.add_trace(go.Scatter3d(x=[-80,-80], y=[0,0], z=[0,0], mode='lines', line=dict(color='white', width=0), name="–°–ø—ñ–Ω –ê"))
                fig.add_trace(go.Scatter3d(x=[80,80], y=[0,0], z=[0,0], mode='lines', line=dict(color='white', width=0), name="–°–ø—ñ–Ω –ë"))

                fig.update_layout(
                    title="–ê–Ω—ñ–º–∞—Ü—ñ—è –ö–æ–ª–∞–ø—Å—É",
                    width=700, height=400,
                    scene=dict(xaxis=dict(range=[-100,100], visible=False), yaxis=dict(range=[-50,50], visible=False), zaxis=dict(range=[-40,40], visible=False), bgcolor='black'),
                    updatemenus=[dict(type="buttons", buttons=[dict(label="‚ñ∂Ô∏è –°—Ç–∞—Ä—Ç", method="animate", args=[None, dict(frame=dict(duration=40, redraw=True), fromcurrent=True)])])]
                )
                fig.frames = frames
                st.plotly_chart(fig)

            else:
                # –°—Ç–∞—Ç–∏—á–Ω–∏–π –≤–∏–≥–ª—è–¥ –¥–æ –∞–Ω—ñ–º–∞—Ü—ñ—ó
                fig_s = go.Figure()
                fig_s.add_trace(go.Scatter3d(x=sx, y=sy, z=sz, mode='markers', marker=dict(size=1, color='white', opacity=0.5)))
                fig_s.add_trace(go.Scatter3d(x=[-80, 80], y=[0,0], z=[0,0], mode='markers+text', text=["üåç –ó–ï–ú–õ–Ø", "üåå –ê–ù–î–†–û–ú–ï–î–ê"], marker=dict(size=[25, 35], color=['blue', 'purple'])))
                fig_s.update_layout(width=700, height=400, scene=dict(xaxis=dict(visible=False), yaxis=dict(visible=False), zaxis=dict(visible=False), bgcolor='black'))
                st.plotly_chart(fig_s, use_container_width=True)

        # --- –î–ï–¢–ê–õ–¨–ù–ï –ü–û–Ø–°–ù–ï–ù–ù–Ø (–ï–í–ï–†–ï–¢–¢) ---
        st.markdown("---")
        st.subheader("üåå –ü–æ—è—Å–Ω–µ–Ω–Ω—è: –¢–µ–æ—Ä—ñ—è –ï–≤–µ—Ä–µ—Ç—Ç–∞ (–ë–∞–≥–∞—Ç–æ—Å–≤—ñ—Ç–æ–≤–∞ —ñ–Ω—Ç–µ—Ä–ø—Ä–µ—Ç–∞—Ü—ñ—è)")
        st.markdown(r"""
        –¶—è –∞–Ω—ñ–º–∞—Ü—ñ—è –ø–æ–∫–∞–∑—É—î –≥–æ–ª–æ–≤–Ω–∏–π –ø–∞—Ä–∞–¥–æ–∫—Å –∫–≤–∞–Ω—Ç–æ–≤–æ—ó –º–µ—Ö–∞–Ω—ñ–∫–∏: —è–∫ —ñ–Ω—Ñ–æ—Ä–º–∞—Ü—ñ—è –º–æ–∂–µ –ø–µ—Ä–µ–¥–∞–≤–∞—Ç–∏—Å—è –º–∏—Ç—Ç—î–≤–æ, —à–≤–∏–¥—à–µ –∑–∞ —Å–≤—ñ—Ç–ª–æ? –ñ–æ–≤—Ç–∞ —Ç–æ—á–∫–∞ (—Å–≤—ñ—Ç–ª–æ) –ª–µ–¥–≤–µ –≤—Å—Ç–∏–≥–ª–∞ –∑—Ä—É—à–∏—Ç–∏, –∞ —Å–ø—ñ–Ω –Ω–∞ –ê–Ω–¥—Ä–æ–º–µ–¥—ñ –≤–∂–µ –∑–º—ñ–Ω–∏–≤—Å—è.
        
        **–¢–µ–æ—Ä—ñ—è –ì'—é –ï–≤–µ—Ä–µ—Ç—Ç–∞ (1957)** –¥–∞—î –¥–∏–≤–æ–≤–∏–∂–Ω–µ –ø–æ—è—Å–Ω–µ–Ω–Ω—è, —è–∫–µ —Ä—è—Ç—É—î —Ç–µ–æ—Ä—ñ—é –≤—ñ–¥–Ω–æ—Å–Ω–æ—Å—Ç—ñ:
        
        1.  **–£–Ω—ñ–≤–µ—Ä—Å–∞–ª—å–Ω–∞ –•–≤–∏–ª—å–æ–≤–∞ –§—É–Ω–∫—Ü—ñ—è:** –í–µ—Å—å –í—Å–µ—Å–≤—ñ—Ç –æ–ø–∏—Å—É—î—Ç—å—Å—è —î–¥–∏–Ω–æ—é —Ö–≤–∏–ª—å–æ–≤–æ—é —Ñ—É–Ω–∫—Ü—ñ—î—é, —è–∫–∞ –º—ñ—Å—Ç–∏—Ç—å —É —Å–æ–±—ñ *–≤—Å—ñ –º–æ–∂–ª–∏–≤—ñ* –≤–∞—Ä—ñ–∞–Ω—Ç–∏ –ø–æ–¥—ñ–π. –î–æ –≤–∏–º—ñ—Ä—é–≤–∞–Ω–Ω—è —Å–∏—Å—Ç–µ–º–∞ –∑–Ω–∞—Ö–æ–¥–∏—Ç—å—Å—è –≤ —Å—Ç–∞–Ω—ñ:
            $$ |\Psi\rangle = \frac{1}{\sqrt{2}} (| \uparrow_A \downarrow_B \rangle - | \downarrow_A \uparrow_B \rangle) $$
        
        2.  **–ù–µ–º–∞—î –∫–æ–ª–∞–ø—Å—É:** –ö–æ–ª–∏ –ê–ª—ñ—Å–∞ –≤–∏–º—ñ—Ä—é—î —Å–ø—ñ–Ω, —Ö–≤–∏–ª—å–æ–≤–∞ —Ñ—É–Ω–∫—Ü—ñ—è –Ω–µ "—Å—Ö–ª–æ–ø—É—î—Ç—å—Å—è" –≤–∏–ø–∞–¥–∫–æ–≤–æ. –ó–∞–º—ñ—Å—Ç—å —Ü—å–æ–≥–æ, **–í—Å–µ—Å–≤—ñ—Ç —Ä–æ–∑–≥–∞–ª—É–∂—É—î—Ç—å—Å—è**.
        
        3.  **–ü–∞—Ä–∞–ª–µ–ª—å–Ω—ñ —Å–≤—ñ—Ç–∏:**
            * –í –æ–¥–Ω—ñ–π –≥—ñ–ª—Ü—ñ —Ä–µ–∞–ª—å–Ω–æ—Å—Ç—ñ —ñ—Å–Ω—É—î –ê–ª—ñ—Å–∞, —è–∫–∞ –ø–æ–±–∞—á–∏–ª–∞ **–í–ì–û–†–£**, —ñ –ë–æ–±, —è–∫–∏–π –º–∞—î —Å–ø—ñ–Ω **–í–ù–ò–ó**.
            * –í —ñ–Ω—à—ñ–π –≥—ñ–ª—Ü—ñ —ñ—Å–Ω—É—î –∫–æ–ø—ñ—è –ê–ª—ñ—Å–∏, —è–∫–∞ –ø–æ–±–∞—á–∏–ª–∞ **–í–ù–ò–ó**, —ñ –∫–æ–ø—ñ—è –ë–æ–±–∞ –∑—ñ —Å–ø—ñ–Ω–æ–º **–í–ì–û–†–£**.
            
        **–ß–æ–º—É —Ü–µ –≤–∏—Ä—ñ—à—É—î –ø—Ä–æ–±–ª–µ–º—É?**
        –Ü–Ω—Ñ–æ—Ä–º–∞—Ü—ñ—è –Ω–µ –ø–µ—Ä–µ–¥–∞–≤–∞–ª–∞—Å—è –≤—ñ–¥ –ó–µ–º–ª—ñ –¥–æ –ê–Ω–¥—Ä–æ–º–µ–¥–∏. –û–±–∏–¥–≤—ñ –≥—ñ–ª–∫–∏ —Ä–µ–∞–ª—å–Ω–æ—Å—Ç—ñ —ñ—Å–Ω—É–≤–∞–ª–∏ –≤ –ø–æ—Ç–µ–Ω—Ü—ñ–∞–ª—ñ –∑–∞–≤–∂–¥–∏. –í–∏–º—ñ—Ä—é–≤–∞–Ω–Ω—è –ø—Ä–æ—Å—Ç–æ –≤–∏–∑–Ω–∞—á–∏–ª–æ, **–≤ —è–∫—ñ–π —Å–∞–º–µ –≥—ñ–ª—Ü—ñ** –æ–ø–∏–Ω–∏–ª–∞—Å—è –≤–∞—à–∞ —Å–≤—ñ–¥–æ–º—ñ—Å—Ç—å. –î–ª—è –ë–æ–±–∞ –Ω–∞ –ê–Ω–¥—Ä–æ–º–µ–¥—ñ –Ω—ñ—á–æ–≥–æ –Ω–µ –∑–º—ñ–Ω–∏–ª–æ—Å—è, –ø–æ–∫–∏ –≤—ñ–Ω —Å–∞–º –Ω–µ –∑—Ä–æ–±–∏—Ç—å –≤–∏–º—ñ—Ä—é–≤–∞–Ω–Ω—è —ñ –Ω–µ –¥—ñ–∑–Ω–∞—î—Ç—å—Å—è, –≤ —è–∫—É –≥—ñ–ª–∫—É –ø–æ—Ç—Ä–∞–ø–∏–≤ –≤—ñ–Ω (—Ü–µ –∑–∞–≤–∂–¥–∏ –±—É–¥–µ —Ç–∞ —Å–∞–º–∞ –≥—ñ–ª–∫–∞, —â–æ –π —É –≤–∞—Å, –¥–ª—è —É–∑–≥–æ–¥–∂–µ–Ω–æ—Å—Ç—ñ —ñ—Å—Ç–æ—Ä—ñ—ó).
        """)

if __name__ == "__main__":
    run_entanglement_simulation()

################ FILE: ./pages/hydrogen_simulation.py ################

import streamlit as st
import numpy as np
import matplotlib
# –í—Å—Ç–∞–Ω–æ–≤–ª—é—î–º–æ –±–µ–∫–µ–Ω–¥ Agg –ø–µ—Ä–µ–¥ —ñ–º–ø–æ—Ä—Ç–æ–º pyplot, —â–æ–± —É–Ω–∏–∫–Ω—É—Ç–∏ –ø–æ–º–∏–ª–æ–∫ –ø–æ—Ç–æ–∫—ñ–≤ GUI
matplotlib.use('Agg')
import matplotlib.pyplot as plt
from scipy import constants
from scipy import optimize

# -------------------------------------------------------------------------
# 1. –ö–û–ù–§–ò–ì–£–†–ê–¶–ò–Ø –ò –ö–û–ù–°–¢–ê–ù–¢–´
# -------------------------------------------------------------------------
HBAR = constants.hbar
M_E = constants.m_e
M_P = constants.m_p
EV = constants.electron_volt

st.set_page_config(layout="wide", page_title="–ü–æ—Ç–µ–Ω—Ü–∏–∞–ª—å–Ω–∞—è –Ø–º–∞: –ö–æ–Ω–µ—á–Ω–∞—è –∏ –ë–µ—Å–∫–æ–Ω–µ—á–Ω–∞—è")

# -------------------------------------------------------------------------
# 2. –í–°–ü–û–ú–û–ì–ê–¢–ï–õ–¨–ù–´–ï –§–£–ù–ö–¶–ò–ò –í–ò–ó–£–ê–õ–ò–ó–ê–¶–ò–ò
# -------------------------------------------------------------------------
def draw_arrow(ax, x1, x2, y, text, color='white'):
    """–†–∏—Å—É–µ—Ç —Å—Ç—Ä–µ–ª–∫—É —Ä–∞–∑–º–µ—Ä–∞."""
    ax.annotate('', xy=(x1, y), xytext=(x2, y), arrowprops=dict(arrowstyle='<->', color=color))
    ax.text((x1 + x2) / 2.0, y, text, ha='center', va='bottom', color=color,
            bbox=dict(facecolor='#0e1117', alpha=0.9, edgecolor='none', boxstyle='round,pad=0.1'))

def plot_setup(ax, title, y_limit_ref, L):
    """–ù–∞—Å—Ç—Ä–æ–π–∫–∞ –æ—Å–µ–π –∏ —Ü–≤–µ—Ç–æ–≤ –≥—Ä–∞—Ñ–∏–∫–∞."""
    ax.set_title(title, color='white', fontsize=16)
    ax.set_xlabel("x (–º)", color='white', fontsize=12)
    ax.set_ylabel("–≠–Ω–µ—Ä–≥–∏—è (—ç–í)", color='white', fontsize=12)
    
    # –ñ–µ—Å—Ç–∫–∏–µ –≥—Ä–∞–Ω–∏—Ü—ã –ø–æ Y –¥–ª—è –≤–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏–∏
    ymin = -abs(y_limit_ref) * 0.1
    ymax = abs(y_limit_ref) * 1.5
    ax.set_ylim(ymin, ymax)
    
    # –†–∞—Å—à–∏—Ä—è–µ–º –≥—Ä–∞–Ω–∏—Ü—ã –ø–æ X
    ax.set_xlim(-L * 0.5, L * 1.8)
    
    ax.tick_params(colors='white', which='both')
    for spine in ['left', 'bottom', 'right', 'top']:
        ax.spines[spine].set_color('white')
    
    ax.set_facecolor('#0e1117')
    fig = ax.figure
    fig.patch.set_facecolor('#0e1117')

# -------------------------------------------------------------------------
# 3. –ú–ê–¢–ï–ú–ê–¢–ò–ß–ï–°–ö–û–ï –Ø–î–†–û (–ö–û–ù–ï–ß–ù–ê–Ø –Ø–ú–ê)
# -------------------------------------------------------------------------
def solve_finite_well_energies(m, L, U0):
    """–ù–∞—Ö–æ–¥–∏—Ç —É—Ä–æ–≤–Ω–∏ —ç–Ω–µ—Ä–≥–∏–∏ –¥–ª—è –ö–û–ù–ï–ß–ù–û–ô —è–º—ã –º–µ—Ç–æ–¥–æ–º –ë—Ä–µ–Ω—Ç–∞."""
    if U0 <= 0 or L <= 0:
        return []

    # P - –ø–∞—Ä–∞–º–µ—Ç—Ä –º–æ—â–Ω–æ—Å—Ç–∏ —è–º—ã
    P = (np.sqrt(2 * m * U0) * L) / (2 * HBAR)
    max_z = P 
    
    roots_z = []
    
    def eq_even(z):
        term = np.maximum((P/z)**2 - 1, 0)
        return np.tan(z) - np.sqrt(term)
    
    def eq_odd(z):
        term = np.maximum((P/z)**2 - 1, 0)
        return -1.0/np.tan(z) - np.sqrt(term)

    n_levels = int(1 + np.floor(2 * P / np.pi))
    
    for n in range(n_levels):
        lower = n * (np.pi / 2.0) + 1e-4
        upper = min((n + 1) * (np.pi / 2.0) - 1e-4, max_z - 1e-6)
        
        if lower >= upper: continue
            
        try:
            if n % 2 == 0: # –ß–µ—Ç–Ω—ã–µ (Even)
                res = optimize.brentq(eq_even, lower, upper)
                roots_z.append((res, 'even'))
            else: # –ù–µ—á–µ—Ç–Ω—ã–µ (Odd)
                res = optimize.brentq(eq_odd, lower, upper)
                roots_z.append((res, 'odd'))
        except ValueError:
            pass 
            
    energies = []
    for z, parity in roots_z:
        E = (2.0 * HBAR * z / L)**2 / (2.0 * m)
        if E < U0: 
            energies.append({
                'E': E,
                'z': z,
                'parity': parity,
                'k': 2.0 * z / L,
                'kappa': np.sqrt(2 * m * (U0 - E)) / HBAR
            })
    
    energies.sort(key=lambda x: x['E'])
    return energies

def get_wavefunction_finite(x_plot, energy_data, L):
    """–°—Ç—Ä–æ–∏—Ç –≤–æ–ª–Ω–æ–≤—É—é —Ñ—É–Ω–∫—Ü–∏—é –¥–ª—è –ö–û–ù–ï–ß–ù–û–ô —è–º—ã."""
    x_math = x_plot - L/2.0 # –¶–µ–Ω—Ç—Ä–∏—Ä—É–µ–º –¥–ª—è –º–∞—Ç–µ–º–∞—Ç–∏–∫–∏
    
    psi = np.zeros_like(x_math)
    k = energy_data['k']
    kappa = energy_data['kappa']
    parity = energy_data['parity']
    a = L / 2.0 
    
    A_in = 1.0
    
    if parity == 'even':
        val_edge = np.cos(k * a)
        A_out = val_edge * np.exp(kappa * a)
        for i, x in enumerate(x_math):
            if abs(x) <= a:
                psi[i] = A_in * np.cos(k * x)
            else:
                psi[i] = A_out * np.exp(-kappa * abs(x))
    else:
        val_edge = np.sin(k * a)
        A_out = val_edge * np.exp(kappa * a)
        for i, x in enumerate(x_math):
            if abs(x) <= a:
                psi[i] = A_in * np.sin(k * x)
            else:
                psi[i] = A_out * np.exp(-kappa * abs(x))
                if x < 0: psi[i] *= -1
                
    norm = np.sqrt(np.trapz(psi**2, x_math))
    if norm > 0:
        psi /= norm
        
    return psi

# -------------------------------------------------------------------------
# 4. –ú–ê–¢–ï–ú–ê–¢–ò–ß–ï–°–ö–û–ï –Ø–î–†–û (–ë–ï–°–ö–û–ù–ï–ß–ù–ê–Ø –Ø–ú–ê)
# -------------------------------------------------------------------------
def solve_inf_well_energies(m, L, n_max=10):
    """–ù–∞—Ö–æ–¥–∏—Ç —É—Ä–æ–≤–Ω–∏ —ç–Ω–µ—Ä–≥–∏–∏ –¥–ª—è –ë–ï–°–ö–û–ù–ï–ß–ù–û–ô —è–º—ã (–∞–Ω–∞–ª–∏—Ç–∏—á–µ—Å–∫–∏)."""
    energies = []
    for n in range(1, n_max + 1):
        E = (n**2 * np.pi**2 * HBAR**2) / (2.0 * m * L**2)
        # –í —Å–∏–º–º–µ—Ç—Ä–∏—á–Ω–æ–π —è–º–µ n=1 (—á–µ—Ç–Ω–∞—è), n=2 (–Ω–µ—á–µ—Ç–Ω–∞—è)
        parity = 'even' if n % 2 != 0 else 'odd' 
        energies.append({
            'E': E,
            'n': n,
            'parity': parity
        })
    return energies

def get_wavefunction_inf(x_plot, n, L):
    """–°—Ç—Ä–æ–∏—Ç –≤–æ–ª–Ω–æ–≤—É—é —Ñ—É–Ω–∫—Ü–∏—é –¥–ª—è –ë–ï–°–ö–û–ù–ï–ß–ù–û–ô —è–º—ã."""
    psi = np.zeros_like(x_plot)
    mask = (x_plot >= 0) & (x_plot <= L)
    psi[mask] = np.sqrt(2.0 / L) * np.sin(n * np.pi * x_plot[mask] / L)
    return psi

# -------------------------------------------------------------------------
# 5. –ò–ù–¢–ï–†–§–ï–ô–° –ò –õ–û–ì–ò–ö–ê
# -------------------------------------------------------------------------
def main():
    st.sidebar.title("üéõ –ü–∞–Ω–µ–ª—å –£–ø—Ä–∞–≤–ª–µ–Ω–∏—è")
    st.sidebar.header("1. –ß–∞—Å—Ç–∏—Ü–∞")

    particle_name = st.sidebar.selectbox("–í—ã–±–µ—Ä–∏—Ç–µ —á–∞—Å—Ç–∏—Ü—É:", ["–≠–ª–µ–∫—Ç—Ä–æ–Ω", "–ü—Ä–æ—Ç–æ–Ω", "–ú—é–æ–Ω"])
    mass_map = {"–≠–ª–µ–∫—Ç—Ä–æ–Ω": M_E, "–ü—Ä–æ—Ç–æ–Ω": M_P, "–ú—é–æ–Ω": M_E * 206.768}
    m = mass_map[particle_name]

    st.sidebar.header("2. –ü–∞—Ä–∞–º–µ—Ç—Ä—ã –Ø–º—ã")
    
    # –í—ã–±–æ—Ä —Ç–∏–ø–∞ —è–º—ã
    well_type = st.sidebar.radio("–¢–∏–ø —Å—Ç–µ–Ω–æ–∫:", ["–ö–æ–Ω–µ—á–Ω—ã–µ —Å—Ç–µ–Ω–∫–∏", "–ë–µ—Å–∫–æ–Ω–µ—á–Ω—ã–µ —Å—Ç–µ–Ω–∫–∏"])
    
    L_val = st.sidebar.number_input("–®–∏—Ä–∏–Ω–∞ L (–º)", value=1e-9, step=1e-10, format="%.2e")
    
    # –ü–æ—Ç–µ–Ω—Ü–∏–∞–ª —Ç–æ–ª—å–∫–æ –¥–ª—è –∫–æ–Ω–µ—á–Ω–æ–π —è–º—ã
    if well_type == "–ö–æ–Ω–µ—á–Ω—ã–µ —Å—Ç–µ–Ω–∫–∏":
        U0_val_ev = st.sidebar.number_input("–ü–æ—Ç–µ–Ω—Ü–∏–∞–ª U‚ÇÄ (—ç–í)", value=10.0, step=0.1, format="%.2f")
        U0_val = U0_val_ev * EV
    else:
        U0_val_ev = None
        U0_val = None

    st.sidebar.markdown("---")
    
    # --- –ë–õ–û–ö 1: –ó–ê–ì–û–õ–û–í–û–ö –ò –ü–ê–†–ù–û–°–¢–¨ ---
    title_text = "–ö–æ–Ω–µ—á–Ω–∞—è –ü–æ—Ç–µ–Ω—Ü–∏–∞–ª—å–Ω–∞—è –Ø–º–∞" if well_type == "–ö–æ–Ω–µ—á–Ω—ã–µ —Å—Ç–µ–Ω–∫–∏" else "–ë–µ—Å–∫–æ–Ω–µ—á–Ω–∞—è –ü–æ—Ç–µ–Ω—Ü–∏–∞–ª—å–Ω–∞—è –Ø–º–∞"
    st.title(f"üì¶ {title_text}")

    with st.container():
        st.markdown("""
        ### üåó –ß—Ç–æ —Ç–∞–∫–æ–µ –ü–∞—Ä–Ω–æ—Å—Ç—å (Parity)?
        –í –∫–≤–∞–Ω—Ç–æ–≤–æ–π –º–µ—Ö–∞–Ω–∏–∫–µ, –µ—Å–ª–∏ –ø–æ—Ç–µ–Ω—Ü–∏–∞–ª —Å–∏–º–º–µ—Ç—Ä–∏—á–µ–Ω ($U(x) = U(-x)$), –≤–æ–ª–Ω–æ–≤—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏ –∏–º–µ—é—Ç –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–Ω—É—é **–ø–∞—Ä–Ω–æ—Å—Ç—å**:
        
        * **–ü–∞—Ä–Ω–∞—è (–ß–µ—Ç–Ω–∞—è / Even) (+):** –§—É–Ω–∫—Ü–∏—è —Å–∏–º–º–µ—Ç—Ä–∏—á–Ω–∞, $\Psi(-x) = \Psi(x)$.
        * **–ù–µ–ø–∞—Ä–Ω–∞—è (–ù–µ—á–µ—Ç–Ω–∞—è / Odd) (-):** –§—É–Ω–∫—Ü–∏—è –∞–Ω—Ç–∏—Å–∏–º–º–µ—Ç—Ä–∏—á–Ω–∞, $\Psi(-x) = -\Psi(x)$.
        """)
        st.info("–£—Ä–æ–≤–Ω–∏ —ç–Ω–µ—Ä–≥–∏–∏ –≤—Å–µ–≥–¥–∞ —á–µ—Ä–µ–¥—É—é—Ç—Å—è: —á–µ—Ç–Ω—ã–π, –Ω–µ—á–µ—Ç–Ω—ã–π, —á–µ—Ç–Ω—ã–π...")

    # --- –õ–û–ì–ò–ö–ê –†–ê–°–ß–ï–¢–ê –ò –í–ò–ó–£–ê–õ–ò–ó–ê–¶–ò–ò ---
    
    if well_type == "–ö–æ–Ω–µ—á–Ω—ã–µ —Å—Ç–µ–Ω–∫–∏":
        # === –õ–û–ì–ò–ö–ê –ö–û–ù–ï–ß–ù–û–ô –Ø–ú–´ ===
        energies_data = solve_finite_well_energies(m, L_val, U0_val)
        
        if not energies_data:
            st.error("–°–≤—è–∑–∞–Ω–Ω—ã—Ö —É—Ä–æ–≤–Ω–µ–π –Ω–µ –Ω–∞–π–¥–µ–Ω–æ. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ —É–≤–µ–ª–∏—á–∏—Ç—å —à–∏—Ä–∏–Ω—É —è–º—ã –∏–ª–∏ –ø–æ—Ç–µ–Ω—Ü–∏–∞–ª.")
            return

        num_levels = len(energies_data)
        n_viz = st.slider("–ö–≤–∞–Ω—Ç–æ–≤–æ–µ —á–∏—Å–ª–æ n", 1, num_levels, 1)
        
        state = energies_data[n_viz - 1]
        E_n = state['E']
        parity_str = "–ß–µ—Ç–Ω–∞—è (Even)" if state['parity'] == 'even' else "–ù–µ—á–µ—Ç–Ω–∞—è (Odd)"
        
        # –ú–µ—Ç—Ä–∏–∫–∏
        c1, c2, c3 = st.columns(3)
        c1.metric("–ö–≤–∞–Ω—Ç–æ–≤–æ–µ —á–∏—Å–ª–æ", f"n = {n_viz}")
        c2.metric("–≠–Ω–µ—Ä–≥–∏—è E", f"{E_n/EV:.4f} —ç–í")
        c3.metric("–ü–∞—Ä–Ω–æ—Å—Ç—å", parity_str)

        # –ì—Ä–∞—Ñ–∏–∫
        fig, ax = plt.subplots(figsize=(12, 7))
        plot_setup(ax, f"–ö–æ–Ω–µ—á–Ω–∞—è —è–º–∞: n={n_viz} ({parity_str})", U0_val_ev, L_val)
        
        x_viz = np.linspace(-L_val * 0.5, L_val * 1.5, 1200)
        
        # –ü–æ—Ç–µ–Ω—Ü–∏–∞–ª
        U_pot = np.where((x_viz >= 0) & (x_viz <= L_val), 0.0, U0_val_ev)
        ax.plot(x_viz, U_pot, 'w-', lw=2, alpha=0.6, label='–ü–æ—Ç–µ–Ω—Ü–∏–∞–ª U(x)')
        
        # –≠–Ω–µ—Ä–≥–∏—è
        E_ev = E_n / EV
        ax.hlines(E_ev, x_viz[0], L_val * 1.4, colors='red', linestyles='--', linewidth=1.5)
        ax.text(L_val * 1.42, E_ev, f" $E_{n_viz} = {E_ev:.3f}$ —ç–í", color='red', fontsize=12, va='center', fontweight='bold')
        
        # –í–æ–ª–Ω–∞
        psi = get_wavefunction_finite(x_viz, state, L_val)
        scale = U0_val_ev * 0.25
        
        psi_norm = psi / np.max(np.abs(psi)) if np.max(np.abs(psi)) > 0 else psi
        psi_plot = E_ev + psi_norm * scale
        prob_plot = E_ev + (psi_norm**2) * scale
        
        ax.plot(x_viz, psi_plot, color='cyan', lw=2.5, label=r'$\Psi_n(x)$')
        ax.fill_between(x_viz, E_ev, psi_plot, color='cyan', alpha=0.2)
        ax.plot(x_viz, prob_plot, color='lime', linestyle=':', lw=1.5, alpha=0.7, label=r'$|\Psi|^2$')
        
        draw_arrow(ax, 0, L_val, -U0_val_ev * 0.05, f"L = {L_val:.1e} –º")
        ax.legend(loc='upper right', facecolor='#0e1117', labelcolor='white', framealpha=0.8)
        st.pyplot(fig)
        
        # –¢–µ–æ—Ä–∏—è –¥–ª—è –∫–æ–Ω–µ—á–Ω–æ–π
        st.markdown("---")
        st.header("üìö –¢–µ–æ—Ä–∏—è: –ö–æ–Ω–µ—á–Ω–∞—è —è–º–∞")
        col_t, col_e = st.columns(2)
        with col_t:
            st.markdown(r"""
            **–û—Å–æ–±–µ–Ω–Ω–æ—Å—Ç–∏:**
            1. **–¢—É–Ω–Ω–µ–ª—å–Ω—ã–π —ç—Ñ—Ñ–µ–∫—Ç:** –í–æ–ª–Ω–æ–≤–∞—è —Ñ—É–Ω–∫—Ü–∏—è –ø—Ä–æ–Ω–∏–∫–∞–µ—Ç –≤ —Å—Ç–µ–Ω–∫–∏ ($e^{-\kappa x}$).
            2. **–ö–æ–Ω–µ—á–Ω–æ–µ —á–∏—Å–ª–æ —É—Ä–æ–≤–Ω–µ–π:** –ß–∞—Å—Ç–∏—Ü–∞ –º–æ–∂–µ—Ç –ø–æ–∫–∏–Ω—É—Ç—å —è–º—É, –µ—Å–ª–∏ $E > U_0$.
            """)
        with col_e:
            st.markdown("**–ü—Ä–∏–º–µ—Ä—ã:** –ö–≤–∞–Ω—Ç–æ–≤—ã–µ —Ç–æ—á–∫–∏, –∞—Ç–æ–º–Ω–æ–µ —è–¥—Ä–æ, –≥–µ—Ç–µ—Ä–æ—Å—Ç—Ä—É–∫—Ç—É—Ä—ã.")

    else:
        # === –õ–û–ì–ò–ö–ê –ë–ï–°–ö–û–ù–ï–ß–ù–û–ô –Ø–ú–´ ===
        energies_data = solve_inf_well_energies(m, L_val, n_max=10)
        
        n_viz = st.slider("–ö–≤–∞–Ω—Ç–æ–≤–æ–µ —á–∏—Å–ª–æ n", 1, 10, 1)
        state = energies_data[n_viz - 1]
        E_n = state['E']
        parity_str = "–ß–µ—Ç–Ω–∞—è (Even)" if n_viz % 2 != 0 else "–ù–µ—á–µ—Ç–Ω–∞—è (Odd)"

        c1, c2, c3 = st.columns(3)
        c1.metric("–ö–≤–∞–Ω—Ç–æ–≤–æ–µ —á–∏—Å–ª–æ", f"n = {n_viz}")
        c2.metric("–≠–Ω–µ—Ä–≥–∏—è E", f"{E_n/EV:.4f} —ç–í")
        c3.metric("–ü–∞—Ä–Ω–æ—Å—Ç—å", parity_str)

        fig, ax = plt.subplots(figsize=(12, 7))
        # –î–ª—è –º–∞—Å—à—Ç–∞–±–∞ –±–µ—Ä–µ–º —Ç–µ–∫—É—â—É—é —ç–Ω–µ—Ä–≥–∏—é –∫–∞–∫ —Ä–µ—Ñ–µ—Ä–µ–Ω—Å (–Ω–µ–º–Ω–æ–≥–æ –≤—ã—à–µ –Ω–µ–µ)
        plot_setup(ax, f"–ë–µ—Å–∫–æ–Ω–µ—á–Ω–∞—è —è–º–∞: n={n_viz}", E_n/EV * 1.5, L_val)
        
        x_viz = np.linspace(-L_val * 0.2, L_val * 1.2, 1000)
        
        # –°—Ç–µ–Ω–∫–∏ (–±–µ—Å–∫–æ–Ω–µ—á–Ω—ã–µ) - —Ä–∏—Å—É–µ–º –≤–µ—Ä—Ç–∏–∫–∞–ª—å–Ω—ã–µ –ª–∏–Ω–∏–∏
        ax.vlines([0, L_val], -E_n/EV * 0.1, E_n/EV * 2, colors='white', linewidth=3, label='–°—Ç–µ–Ω–∫–∏ ($\infty$)')
        ax.hlines(0, -L_val*0.2, L_val*1.2, color='white', lw=1)
        
        # –≠–Ω–µ—Ä–≥–∏—è
        E_ev = E_n / EV
        ax.hlines(E_ev, x_viz[0], L_val * 1.4, colors='red', linestyles='--', linewidth=1.5)
        ax.text(L_val * 1.42, E_ev, f" $E_{n_viz} = {E_ev:.3f}$ —ç–í", color='red', fontsize=12, va='center', fontweight='bold')
        
        # –í–æ–ª–Ω–∞
        psi = get_wavefunction_inf(x_viz, n_viz, L_val)
        
        scale = E_ev * 0.4
        
        psi_norm = psi / np.max(np.abs(psi)) if np.max(np.abs(psi)) > 0 else psi
        psi_plot = E_ev + psi_norm * scale
        prob_plot = E_ev + (psi_norm**2) * scale
        
        ax.plot(x_viz, psi_plot, color='cyan', lw=2.5, label=r'$\Psi_n(x)$')
        ax.fill_between(x_viz, E_ev, psi_plot, color='cyan', alpha=0.2)
        ax.plot(x_viz, prob_plot, color='lime', linestyle=':', lw=1.5, alpha=0.7, label=r'$|\Psi|^2$')
        
        draw_arrow(ax, 0, L_val, -E_ev * 0.05, f"L = {L_val:.1e} –º")
        ax.legend(loc='upper right', facecolor='#0e1117', labelcolor='white', framealpha=0.8)
        st.pyplot(fig)

        # –¢–µ–æ—Ä–∏—è –¥–ª—è –±–µ—Å–∫–æ–Ω–µ—á–Ω–æ–π
        st.markdown("---")
        st.header("üìö –¢–µ–æ—Ä–∏—è: –ë–µ—Å–∫–æ–Ω–µ—á–Ω–∞—è —è–º–∞")
        col_t, col_e = st.columns(2)
        with col_t:
            st.markdown(r"""
            **–û—Å–æ–±–µ–Ω–Ω–æ—Å—Ç–∏:**
            1. **–ò–¥–µ–∞–ª—å–Ω–∞—è –º–æ–¥–µ–ª—å:** –°—Ç–µ–Ω–∫–∏ –Ω–µ–ø—Ä–æ–Ω–∏—Ü–∞–µ–º—ã ($U = \infty$).
            2. **–í–æ–ª–Ω–æ–≤–∞—è —Ñ—É–Ω–∫—Ü–∏—è:** –°—Ç—Ä–æ–≥–æ –Ω–æ–ª—å –Ω–∞ –≥—Ä–∞–Ω–∏—Ü–∞—Ö.
            3. **–≠–Ω–µ—Ä–≥–∏—è:** –†–∞—Å—Ç–µ—Ç –∫–≤–∞–¥—Ä–∞—Ç–∏—á–Ω–æ $E_n \propto n^2$.
            """)
        with col_e:
            st.markdown("**–§–æ—Ä–º—É–ª–∞:** $E_n = \frac{n^2 \pi^2 \hbar^2}{2mL^2}$")

if __name__ == "__main__":
    main()
    

################ FILE: ./pages/relativity_simulator.py ################

import streamlit as st
import time

# --- CONSTANTS & PHYSICS ---
C = 300000  # Speed of light in km/s (scale)
V = 240000  # Train speed in km/s
GAMMA = 5 / 3  # 1.6666...
L0_KM = 8.64 * 10**8  # Proper length in km

# Initial Time on clocks at first meeting (12:00:00)
T0_SECONDS = 12 * 3600

# Contracted Length
L_CONTRACTED = L0_KM / GAMMA

# Events (in seconds from T0 in Platform Frame K)
T_EVENT_1 = 0
T_EVENT_2 = L_CONTRACTED / V  # 2160 sec
T_EVENT_3 = L0_KM / V  # 3600 sec

# --- HELPER FUNCTIONS ---

def format_time(seconds):
    h = int(seconds // 3600)
    m = int((seconds % 3600) // 60)
    s = int(seconds % 60)
    return f"{h:02}:{m:02}:{s:02}"

def get_train_time(t_k, x_k):
    """
    Lorentz Transformation for Time.
    t, x are in Frame K (Platform). We want t' in Frame K' (Train)
    t' = gamma * (t - v*x / c^2)
    """
    delta = (V * x_k) / (C**2)
    return GAMMA * (t_k - delta)

def get_modal_content(step):
    if step == 1:
        return {
            "title": "–ü–æ–¥—ñ—è 1: –°—Ç–∞—Ä—Ç",
            "desc": "–ù—ñ—Å –ø–æ—ó–∑–¥–∞ (B') –∑—Ä—ñ–≤–Ω—è–≤—Å—è –∑ –ø–æ—á–∞—Ç–∫–æ–º –ø–ª–∞—Ç—Ñ–æ—Ä–º–∏ (A).",
            "calc": "–¶–µ –º–æ–º–µ–Ω—Ç —Å–∏–Ω—Ö—Ä–æ–Ω—ñ–∑–∞—Ü—ñ—ó. –ú–∏ –ø—Ä–∏–π–º–∞—î–º–æ t=12:00:00. –°–ø–æ—Å—Ç–µ—Ä—ñ–≥–∞—á —É –ø–æ—ó–∑–¥—ñ –±–∞—á–∏—Ç—å, —â–æ –≥–æ–¥–∏–Ω–Ω–∏–∫ B (–ø–æ–ø–µ—Ä–µ–¥—É) –≤—ñ–¥—Å—Ç–∞—î —ñ –ø–æ–∫–∞–∑—É—î 10:56:00.",
            "next_step": 2,
            "next_text": "–î–∞–ª—ñ: —á–µ–∫–∞—î–º–æ —Ö–≤–æ—Å—Ç–∞ –ø–æ—ó–∑–¥–∞"
        }
    elif step == 2:
        return {
            "title": "–ü–æ–¥—ñ—è 2: –•–≤—ñ—Å—Ç –Ω–∞ —Å—Ç–∞—Ä—Ç—ñ",
            "desc": "–•–≤—ñ—Å—Ç –ø–æ—ó–∑–¥–∞ (A') –ø–æ—Ä—ñ–≤–Ω—è–≤—Å—è –∑ –ø–æ—á–∞—Ç–∫–æ–º –ø–ª–∞—Ç—Ñ–æ—Ä–º–∏ (A).",
            "calc": "–ù–∞ –ø–ª–∞—Ç—Ñ–æ—Ä–º—ñ –ø—Ä–æ–π—à–ª–æ 36 —Ö–≤ (t=12:36). –ê–ª–µ –Ω–∞ –≥–æ–¥–∏–Ω–Ω–∏–∫—É —Ö–≤–æ—Å—Ç–∞ –ø–æ—ó–∑–¥–∞ 13:00. –•–≤—ñ—Å—Ç '–¥—É–º–∞—î', —â–æ –ø—Ä–æ–π—à–ª–æ –±—ñ–ª—å—à–µ —á–∞—Å—É.",
            "next_step": 3,
            "next_text": "–ü–µ—Ä–µ–π—Ç–∏ –Ω–∞ –∫—ñ–Ω–µ—Ü—å –ø–ª–∞—Ç—Ñ–æ—Ä–º–∏"
        }
    elif step == 3:
        return {
            "title": "–ü–æ–¥—ñ—è 3: –ì–æ–ª–æ–≤–∞ –Ω–∞ —Ñ—ñ–Ω—ñ—à—ñ",
            "desc": "–ù—ñ—Å –ø–æ—ó–∑–¥–∞ (B') –¥—ñ—Å—Ç–∞–≤—Å—è –∫—ñ–Ω—Ü—è –ø–ª–∞—Ç—Ñ–æ—Ä–º–∏ (B).",
            "calc": "–ù–∞ –ø–ª–∞—Ç—Ñ–æ—Ä–º—ñ –ø—Ä–æ–π—à–ª–∞ 1 –≥–æ–¥–∏–Ω–∞ (t=13:00). –ù–∞ –≥–æ–¥–∏–Ω–Ω–∏–∫—É –ø–æ—ó–∑–¥–∞ –ª–∏—à–µ 12:36. –ß–∞—Å —É —Ä—É—Ö–æ–º–æ–º—É –ø–æ—ó–∑–¥—ñ —Å–ø–æ–≤—ñ–ª—å–Ω–∏–≤—Å—è.",
            "next_step": 4,
            "next_text": "–ó–º—ñ–Ω–∏—Ç–∏ —Å–∏—Å—Ç–µ–º—É: –ü–µ—Ä–µ–π—Ç–∏ –≤ –ü–æ—ó–∑–¥"
        }
    elif step == 4:
        return {
            "title": "–°–∏—Å—Ç–µ–º–∞ –ü–æ—ó–∑–¥–∞: –°—Ç–∞—Ä—Ç",
            "desc": "–ú–∏ –≤ –≥–æ–ª–æ–≤—ñ –ø–æ—ó–∑–¥–∞ (B'). –ü–ª–∞—Ç—Ñ–æ—Ä–º–∞ –ª–µ—Ç–∏—Ç—å –Ω–∞ –Ω–∞—Å.",
            "calc": "–ì–æ–¥–∏–Ω–Ω–∏–∫ A –ø–æ–∫–∞–∑—É—î 12:00, –∞ –≥–æ–¥–∏–Ω–Ω–∏–∫ B (–±—ñ–ª—è –Ω–∞—Å) –ø–æ–∫–∞–∑—É—î 10:56. –ü–ª–∞—Ç—Ñ–æ—Ä–º–∞ —Å–∫–æ—Ä–æ—á–µ–Ω–∞.",
            "next_step": 5,
            "next_text": "–á–¥–µ–º–æ –¥–æ –∫—ñ–Ω—Ü—è –ø–ª–∞—Ç—Ñ–æ—Ä–º–∏"
        }
    elif step == 5:
        return {
            "title": "–°–∏—Å—Ç–µ–º–∞ –ü–æ—ó–∑–¥–∞: –§—ñ–Ω—ñ—à –≥–æ–ª–æ–≤–∏",
            "desc": "–ú–∏ –ø—Ä–æ—ó—Ö–∞–ª–∏ –∫—ñ–Ω–µ—Ü—å –ø–ª–∞—Ç—Ñ–æ—Ä–º–∏ (B).",
            "calc": "–ù–∞ –Ω–∞—à–æ–º—É –≥–æ–¥–∏–Ω–Ω–∏–∫—É 12:36. –ù–∞ –≥–æ–¥–∏–Ω–Ω–∏–∫—É B —Ç–µ–∂ 12:36 (–±–æ –≤—ñ–Ω –≤—ñ–¥—Å—Ç–∞–≤–∞–≤ –∑ –ø–æ—á–∞—Ç–∫—É).",
            "next_step": 6,
            "next_text": "–ü–µ—Ä–µ–π—Ç–∏ —É —Ö–≤—ñ—Å—Ç –ø–æ—ó–∑–¥–∞"
        }
    elif step == 6:
        return {
            "title": "–°–∏—Å—Ç–µ–º–∞ –ü–æ—ó–∑–¥–∞: –•–≤—ñ—Å—Ç",
            "desc": "–ú–∏ —É —Ö–≤–æ—Å—Ç—ñ. –ü–ª–∞—Ç—Ñ–æ—Ä–º–∞ –ø—Ä–æ–ª—ñ—Ç–∞—î –ø–æ–≤–∑.",
            "calc": "–ö–æ–ª–∏ –ø–æ—á–∞—Ç–æ–∫ –ø–ª–∞—Ç—Ñ–æ—Ä–º–∏ (A) –ø–æ—Ä—ñ–≤–Ω—è–≤—Å—è –∑ –Ω–∞–º–∏: –Ω–∞—à —á–∞—Å 13:00, —á–∞—Å –ø–ª–∞—Ç—Ñ–æ—Ä–º–∏ A 12:36. –ß–∞—Å –ø–ª–∞—Ç—Ñ–æ—Ä–º–∏ –π–¥–µ –ø–æ–≤—ñ–ª—å–Ω—ñ—à–µ –¥–ª—è –Ω–∞—Å.",
            "next_step": 0,
            "next_text": "–ó–∞–≤–µ—Ä—à–∏—Ç–∏"
        }
    return None

# --- STREAMLIT APP ---

st.set_page_config(page_title="Relativity Simulator", page_icon="üöÑ", layout="wide")

# Initialize Session State
if 'scenario_step' not in st.session_state:
    st.session_state.scenario_step = 0
if 'time_k' not in st.session_state:
    st.session_state.time_k = -1000.0
if 'is_running' not in st.session_state:
    st.session_state.is_running = False

# Constants for Animation
SIM_SPEED_MULTIPLIER = 500  # Sim seconds per Real second
FPS = 30
DT = 1.0 / FPS

# --- LOGIC CONTROL ---

def reset_sim(step):
    st.session_state.scenario_step = step
    st.session_state.time_k = -1000.0
    st.session_state.is_running = False

# Step Logic
step = st.session_state.scenario_step
is_train_frame = step >= 4

# Physics Update Loop (runs when 'is_running' is True)
if st.session_state.is_running:
    # Update time
    st.session_state.time_k += SIM_SPEED_MULTIPLIER * DT
    
    # Check Events
    stop_time = None
    if (step == 1 or step == 4) and st.session_state.time_k >= T_EVENT_1:
        stop_time = T_EVENT_1
    elif (step == 2 or step == 6) and st.session_state.time_k >= T_EVENT_2:
        stop_time = T_EVENT_2
    elif (step == 3 or step == 5) and st.session_state.time_k >= T_EVENT_3:
        stop_time = T_EVENT_3
    
    if stop_time is not None:
        st.session_state.time_k = stop_time
        st.session_state.is_running = False
        st.rerun()
    
    time.sleep(DT)
    st.rerun()

# --- UI RENDERING ---

st.title("üöÑ –°–∏–º—É–ª—è—Ç–æ—Ä –°–¢–í: –ü–æ—ó–∑–¥ –ï–π–Ω—à—Ç–µ–π–Ω–∞")
st.caption(f"v = 240,000 –∫–º/—Å (0.8c) | Œ≥ = {GAMMA:.3f}")

# Header Controls
col1, col2 = st.columns([3, 1])
with col1:
    if step == 0:
        st.info("üëã –õ–∞—Å–∫–∞–≤–æ –ø—Ä–æ—Å–∏–º–æ! –ù–∞—Ç–∏—Å–Ω—ñ—Ç—å –∫–Ω–æ–ø–∫—É –Ω–∏–∂—á–µ, —â–æ–± –ø–æ—á–∞—Ç–∏ –µ–∫—Å–ø–µ—Ä–∏–º–µ–Ω—Ç.")
        if st.button("–ü–æ—á–∞—Ç–∏ –ï–∫—Å–ø–µ—Ä–∏–º–µ–Ω—Ç", type="primary"):
            reset_sim(1)
            st.rerun()
    else:
        # Check if we are stopped at an event
        modal_info = None
        if not st.session_state.is_running:
            # Check precise timing match for event
            if (step == 1 or step == 4) and abs(st.session_state.time_k - T_EVENT_1) < 1: modal_info = get_modal_content(step)
            elif (step == 2 or step == 6) and abs(st.session_state.time_k - T_EVENT_2) < 1: modal_info = get_modal_content(step)
            elif (step == 3 or step == 5) and abs(st.session_state.time_k - T_EVENT_3) < 1: modal_info = get_modal_content(step)

        if modal_info:
            st.success(f"**{modal_info['title']}**")
            st.markdown(f"{modal_info['desc']}")
            st.warning(f"üìê {modal_info['calc']}")
            if st.button(f"{modal_info['next_text']} ‚û°Ô∏è"):
                reset_sim(modal_info['next_step'])
                if modal_info['next_step'] in [1, 4]: # Auto start only on new systems
                     st.session_state.is_running = False 
                else:
                     st.session_state.is_running = False # Wait for user to play? Or auto? Let's wait.
                st.rerun()
        else:
            st.write(f"üëÅÔ∏è **–°–ø–æ—Å—Ç–µ—Ä—ñ–≥–∞—á:** {'–í –ü–æ—ó–∑–¥—ñ (K\')' if is_train_frame else '–ù–∞ –ü–ª–∞—Ç—Ñ–æ—Ä–º—ñ (K)'}")
            
with col2:
    if step > 0:
        t_display = format_time(T0_SECONDS + st.session_state.time_k) if st.session_state.time_k >= 0 else "–ù–∞–±–ª–∏–∂–µ–Ω–Ω—è..."
        st.metric("–°–∏—Å—Ç–µ–º–Ω–∏–π –ß–∞—Å (K)", t_display)
        
        c_play, c_reset = st.columns(2)
        if c_play.button("‚èØÔ∏è –°—Ç–∞—Ä—Ç/–ü–∞—É–∑–∞"):
            st.session_state.is_running = not st.session_state.is_running
            st.rerun()
        if c_reset.button("üîÑ –°–∫–∏–¥–∞–Ω–Ω—è"):
            st.session_state.time_k = -1000.0
            st.session_state.is_running = False
            st.rerun()

# --- VISUALIZATION (SVG via HTML) ---
if step > 0:
    # Calculations for View
    current_time_k = st.session_state.time_k
    head_pos_km = V * current_time_k
    tail_pos_km = head_pos_km - L_CONTRACTED
    
    # Viewport Mapping (0 -> 10%, L0 -> 90%)
    def km_to_pct(km):
        return 10 + (km / L0_KM) * 80
    
    train_width_pct = 80 * (1/GAMMA) # ~48%
    
    # Train Position Logic
    if is_train_frame:
        # Simplified Visuals for Train Frame: Platform moves left.
        platform_left_style = f"{10 - ((V * current_time_k) / L0_KM * 80)}%"
        train_left_style = "26%" # Fixed
        
    else:
        # Platform Static
        platform_left_style = "10%"
        # Train Moves Right
        train_left_pct = km_to_pct(tail_pos_km)
        train_left_style = f"{train_left_pct}%"

    # Clocks
    clock_a = T0_SECONDS + current_time_k
    clock_b = T0_SECONDS + current_time_k
    
    t_prime_head = T0_SECONDS + get_train_time(current_time_k, head_pos_km)
    t_prime_tail = T0_SECONDS + get_train_time(current_time_k, tail_pos_km)
    
    # SVG Content - NO INDENTATION ALLOWED FOR HTML TAGS
    svg_html = f"""
<div style="background-color: #1e293b; border-radius: 10px; padding: 20px; position: relative; height: 300px; overflow: hidden; border: 4px solid #334155;">
<div style="position: absolute; inset: 0; opacity: 0.2; background-image: linear-gradient(#4f46e5 1px, transparent 1px), linear-gradient(90deg, #4f46e5 1px, transparent 1px); background-size: 40px 40px;"></div>
<div style="position: absolute; top: 50%; left: 0; width: 100%; height: 2px; background: rgba(30, 64, 175, 0.5); transform: translateY(10px);"></div>
<div style="position: absolute; top: 50%; left: {platform_left_style}; width: 80%; height: 40px; background: #2563eb; border-bottom: 4px solid #1e40af; transform: translateY(20px); transition: left 0.05s linear; display: flex; justify-content: space-between; align-items: flex-end; padding: 0 10px;">
<div style="color: #60a5fa; font-weight: bold; font-family: sans-serif; position: absolute; top: 100%; width: 100%; text-align: center; margin-top: 5px;">–ü–õ–ê–¢–§–û–†–ú–ê</div>
<div style="position: relative; top: -50px; left: -10px; background: #0f172a; border: 2px solid #3b82f6; padding: 4px; border-radius: 4px; text-align: center; width: 80px;">
<div style="color: #60a5fa; font-size: 10px; font-weight: bold;">A (–ü–ª–∞—Ç)</div>
<div style="color: white; font-family: monospace;">{format_time(clock_a)}</div>
<div style="width: 2px; height: 20px; background: #3b82f6; margin: 0 auto;"></div>
</div>
<div style="position: relative; top: -50px; right: -10px; background: #0f172a; border: 2px solid #3b82f6; padding: 4px; border-radius: 4px; text-align: center; width: 80px;">
<div style="color: #60a5fa; font-size: 10px; font-weight: bold;">B (–ü–ª–∞—Ç)</div>
<div style="color: white; font-family: monospace;">{format_time(clock_b)}</div>
<div style="width: 2px; height: 20px; background: #3b82f6; margin: 0 auto;"></div>
</div>
</div>
<div style="position: absolute; top: 50%; left: {train_left_style}; width: {train_width_pct}%; height: 50px; background: #dc2626; border-bottom: 4px solid #991b1b; transform: translateY(-30px); border-radius: 8px; transition: left 0.05s linear; display: flex; justify-content: space-between; align-items: flex-start; padding: 0 10px; z-index: 10;">
<div style="color: #f87171; font-weight: bold; font-family: sans-serif; position: absolute; bottom: 100%; width: 100%; text-align: center; margin-bottom: 5px;">–ü–û–á–ó–î</div>
<div style="position: relative; top: -60px; left: -10px; background: #0f172a; border: 2px solid #ef4444; padding: 4px; border-radius: 4px; text-align: center; width: 80px;">
<div style="color: #ef4444; font-size: 10px; font-weight: bold;">A' (–ü–æ—ó–∑–¥)</div>
<div style="color: white; font-family: monospace;">{format_time(t_prime_tail)}</div>
<div style="width: 2px; height: 20px; background: #ef4444; margin: 0 auto;"></div>
</div>
<div style="position: relative; top: -60px; right: -10px; background: #0f172a; border: 2px solid #ef4444; padding: 4px; border-radius: 4px; text-align: center; width: 80px;">
<div style="color: #ef4444; font-size: 10px; font-weight: bold;">B' (–ü–æ—ó–∑–¥)</div>
<div style="color: white; font-family: monospace;">{format_time(t_prime_head)}</div>
<div style="width: 2px; height: 20px; background: #ef4444; margin: 0 auto;"></div>
</div>
</div>
</div>
"""
    
    st.markdown(svg_html, unsafe_allow_html=True)
    
    # Legend
    st.markdown("""
    <div style="text-align: right; color: gray; font-size: 12px; margin-top: 5px;">
    üü¶ –ì–æ–¥–∏–Ω–Ω–∏–∫–∏ –ü–ª–∞—Ç—Ñ–æ—Ä–º–∏ (K) | üü• –ì–æ–¥–∏–Ω–Ω–∏–∫–∏ –ü–æ—ó–∑–¥–∞ (K')
    </div>
    """, unsafe_allow_html=True)

# --- SOLUTION TEXT ---
with st.expander("üìñ –î–µ—Ç–∞–ª—å–Ω–µ –ø–æ—è—Å–Ω–µ–Ω–Ω—è —Ç–∞ —Ä–æ–∑—Ä–∞—Ö—É–Ω–∫–∏", expanded=True):
    st.markdown(r"""
    ### 1. –í–∏—Ö—ñ–¥–Ω—ñ –î–∞–Ω—ñ
    * **–®–≤–∏–¥–∫—ñ—Å—Ç—å ($v$):** 240,000 –∫–º/—Å ($0.8c$)
    * **–§–∞–∫—Ç–æ—Ä –õ–æ—Ä–µ–Ω—Ü–∞ ($\gamma$):** $5/3 \approx 1.67$
    * **–í–ª–∞—Å–Ω–∞ –¥–æ–≤–∂–∏–Ω–∞ ($L_0$):** $8.64 \cdot 10^8$ –∫–º
    * **–°–∫–æ—Ä–æ—á–µ–Ω–∞ –¥–æ–≤–∂–∏–Ω–∞ ($L$):** $5.184 \cdot 10^8$ –∫–º

    ### 2. –ö–ª—é—á–æ–≤—ñ –µ—Ñ–µ–∫—Ç–∏
    1.  **–í—ñ–¥–Ω–æ—Å–Ω—ñ—Å—Ç—å –æ–¥–Ω–æ—á–∞—Å–Ω–æ—Å—Ç—ñ:** –ü–æ–¥—ñ—ó, –æ–¥–Ω–æ—á–∞—Å–Ω—ñ –≤ —Å–∏—Å—Ç–µ–º—ñ –ø–ª–∞—Ç—Ñ–æ—Ä–º–∏ ($t_A=t_B$), –Ω–µ —î –æ–¥–Ω–æ—á–∞—Å–Ω–∏–º–∏ –≤ —Å–∏—Å—Ç–µ–º—ñ –ø–æ—ó–∑–¥–∞.
        * –†—ñ–∑–Ω–∏—Ü—è —á–∞—Å—É: $\Delta t' = v L_0 / c^2$.
        * –£ –º–æ–º–µ–Ω—Ç –∑—É—Å—Ç—Ä—ñ—á—ñ ($t=12:00$), —Å–ø–æ—Å—Ç–µ—Ä—ñ–≥–∞—á –Ω–∞ –ø–æ—ó–∑–¥—ñ –±–∞—á–∏—Ç—å –Ω–∞ –≥–æ–¥–∏–Ω–Ω–∏–∫—É $B$ —á–∞—Å **10:56**.
    
    2.  **–£–ø–æ–≤—ñ–ª—å–Ω–µ–Ω–Ω—è —á–∞—Å—É:**
        * –ì–æ–¥–∏–Ω–Ω–∏–∫, —â–æ —Ä—É—Ö–∞—î—Ç—å—Å—è, –π–¥–µ –ø–æ–≤—ñ–ª—å–Ω—ñ—à–µ —É $\gamma$ —Ä–∞–∑—ñ–≤.
        * –ö–æ–ª–∏ –Ω–∞ –ø–ª–∞—Ç—Ñ–æ—Ä–º—ñ –ø—Ä–æ—Ö–æ–¥–∏—Ç—å 1 –≥–æ–¥–∏–Ω–∞, –Ω–∞ –≥–æ–¥–∏–Ω–Ω–∏–∫—É –ø–æ—ó–∑–¥–∞ –ø—Ä–æ—Ö–æ–¥–∏—Ç—å –ª–∏—à–µ 36 —Ö–≤–∏–ª–∏–Ω.
    """)

################ FILE: ./pages/relativitysim_2.py ################

# barrier_only.py
# –¢–Ü–õ–¨–ö–ò –ë–ê–†'–Ñ–† ‚Äî —Å—Ç—Ä–æ–≥–æ –±–µ–∑ –∂–æ–¥–Ω–∏—Ö –∑–º—ñ–Ω (—è–∫ —É —Ç–≤–æ—î–º—É –æ—Ä–∏–≥—ñ–Ω–∞–ª—ñ)

import streamlit as st
import numpy as np
import matplotlib.pyplot as plt
from scipy import constants, linalg

# -------------------------------------------------------------------------
# –ö–û–ù–°–¢–ê–ù–¢–ò
# -------------------------------------------------------------------------
HBAR = constants.hbar
M_E = constants.m_e
EV = constants.electron_volt

# -------------------------------------------------------------------------
# –ë–ê–†'–Ñ–† ‚Äî –¢–û–ß–ù–û –Ø–ö –ë–£–õ–û
# -------------------------------------------------------------------------
class BarrierSolver:
    """–ö–ª–∞—Å –¥–ª—è —Ä–æ–∑—Ä–∞—Ö—É–Ω–∫—É —Ö–≤–∏–ª—å–æ–≤–æ—ó —Ñ—É–Ω–∫—Ü—ñ—ó –¥–ª—è —Å—Ö–æ–¥–∏–Ω–∫–∏ —Ç–∞ –ø—Ä—è–º–æ–∫—É—Ç–Ω–æ–≥–æ –±–∞—Ä'—î—Ä–∞."""
    def __init__(self, m):
        self.m = float(m)
    def solve_step(self, E, U0, x):
        x = np.array(x, dtype=float)
        k1 = get_k(E, self.m, 0.0)
        k1 = complex(k1)
        if E > U0:
            k2 = get_k(E, self.m, U0)
            k2 = complex(k2)
            R_amp = (k1 - k2) / (k1 + k2)
            T_amp = 2.0 * k1 / (k1 + k2)
            psi = np.zeros_like(x, dtype=complex)
            left_mask = x < 0
            right_mask = x >= 0
            psi[left_mask] = np.exp(1j * k1 * x[left_mask]) + R_amp * np.exp(-1j * k1 * x[left_mask])
            psi[right_mask] = T_amp * np.exp(1j * k2 * x[right_mask])
            k1_r = k1.real if abs(k1.real) > 1e-18 else 1e-18
            k2_r = k2.real if abs(k2.real) > 1e-18 else 1e-18
            T = (k2_r / k1_r) * (abs(T_amp)**2)
            R = abs(R_amp)**2
            return np.real(psi), np.abs(psi)**2, T, R
        else:
            k2 = get_k(E, self.m, U0)
            kappa = abs(complex(k2).imag)
            psi = np.zeros_like(x, dtype=complex)
            left_mask = x < 0
            right_mask = x >= 0
            psi[left_mask] = np.exp(1j * k1 * x[left_mask]) + np.exp(-1j * k1 * x[left_mask])
            psi[right_mask] = np.exp(-kappa * x[right_mask])
            return np.real(psi), np.abs(psi)**2, 0.0, 1.0

    def solve_rectangular(self, E, U0, L, x):
        x = np.array(x, dtype=float)
        k1 = complex(get_k(E, self.m, 0.0))
        k2_complex = complex(get_k(E, self.m, U0))
        T = 0.0
        R = 1.0
        try:
            if E > U0:
                k2r = k2_complex.real
                denom = 1.0 + (U0**2 * (np.sin(k2r * L)**2)) / (4.0 * E * (E - U0))
                if denom == 0:
                    T = 0.0
                else:
                    T = 1.0 / denom
            else:
                kappa = abs(k2_complex.imag)
                if kappa * L > 100.0:
                    T = 0.0
                else:
                    denom = 1.0 + (U0**2 * (np.sinh(kappa * L)**2)) / (4.0 * E * (U0 - E))
                    T = 1.0 / denom
            R = max(0.0, 1.0 - T)
        except Exception:
            T = 0.0
            R = 1.0
        psi = np.zeros_like(x, dtype=complex)
        left_mask = x < 0
        mid_mask = (x >= 0) & (x <= L)
        right_mask = x > L
        try:
            k1c = k1
            k2c = k2_complex
            denom_t = 2.0 * k1c * k2c * np.cos(k2c * L) - 1j * (k1c**2 + k2c**2) * np.sin(k2c * L)
            if np.abs(denom_t) < 1e-16:
                t_amp = 0.0
                r_amp = 1.0
            else:
                t_amp = (2.0 * k1c * k2c * np.exp(-1j * k1c * L)) / denom_t
                r_amp = (1j * (k2c**2 - k1c**2) * np.sin(k2c * L)) / denom_t
        except Exception:
            t_amp = 0.0
            r_amp = 1.0
        if np.any(left_mask):
            psi[left_mask] = np.exp(1j * k1 * x[left_mask]) + r_amp * np.exp(-1j * k1 * x[left_mask])
        if np.any(mid_mask):
            try:
                x0 = 0.0
                xL = L
                M = np.array([
                    [np.exp(1j * k2c * x0), np.exp(-1j * k2c * x0)],
                    [1j * k2c * np.exp(1j * k2c * x0), -1j * k2c * np.exp(-1j * k2c * x0)]
                ], dtype=complex)
                psi_left_0 = 1.0 + r_amp
                psi_left_der_0 = 1j * k1 * (1.0 - r_amp)
                b = np.array([psi_left_0, psi_left_der_0], dtype=complex)
                sol = linalg.solve(M, b)
                Acoef, Bcoef = sol[0], sol[1]
            except Exception:
                Acoef, Bcoef = 0.0, 0.0
            psi[mid_mask] = Acoef * np.exp(1j * k2c * x[mid_mask]) + Bcoef * np.exp(-1j * k2c * x[mid_mask])
        if np.any(right_mask):
            psi[right_mask] = t_amp * np.exp(1j * k1 * x[right_mask])
        psi_real = np.real(psi)
        prob = np.abs(psi)**2
        return psi_real, prob, T, R

# -------------------------------------------------------------------------
# –î–û–ü–û–ú–Ü–ñ–ù–Ü –§–£–ù–ö–¶–Ü–á (–∑–∞–ª–∏—à–µ–Ω–æ —Ç—ñ–ª—å–∫–∏ —Ç–µ, —â–æ –ø–æ—Ç—Ä—ñ–±–Ω–æ –¥–ª—è –±–∞—Ä‚Äô—î—Ä—É)
# -------------------------------------------------------------------------
def safe_sqrt_complex(x):
    return np.sqrt(x + 0j)

def get_k(E, m, U=0.0):
    val = 2.0 * m * (E - U)
    return safe_sqrt_complex(val) / HBAR

# -------------------------------------------------------------------------
# –û–°–ù–û–í–ù–ê –§–£–ù–ö–¶–Ü–Ø ‚Äî –¢–Ü–õ–¨–ö–ò –ë–ê–†'–Ñ–†
# -------------------------------------------------------------------------
def run_barrier_sim():
    st.title("–ü–æ—Ç–µ–Ω—Ü—ñ–∞–ª—å–Ω–∏–π –ë–∞—Ä‚Äô—î—Ä —Ç–∞ –°—Ö–æ–¥–∏–Ω–∫–∞")
    
    col1, col2 = st.columns([1, 2])
    with col1:
        barrier_type = st.radio("–¢–∏–ø", ["–ü—Ä—è–º–æ–∫—É—Ç–Ω–∏–π –±–∞—Ä‚Äô—î—Ä", "–°—Ö–æ–¥–∏–Ω–∫–∞"])
        E_ev = st.slider("–ï–Ω–µ—Ä–≥—ñ—è E (–µ–í)", 1.0, 200.0, 40.0)
        U0_ev = st.slider("–í–∏—Å–æ—Ç–∞ U‚ÇÄ (–µ–í)", 10.0, 300.0, 100.0)
        L_nm = st.slider("–®–∏—Ä–∏–Ω–∞ L (–Ω–º)", 0.5, 10.0, 2.0) if barrier_type == "–ü—Ä—è–º–æ–∫—É—Ç–Ω–∏–π –±–∞—Ä‚Äô—î—Ä" else None

    with col2:
        E = E_ev * EV
        U0 = U0_ev * EV
        L = L_nm * 1e-9 if L_nm else 1e-9
        solver = BarrierSolver(M_E)

        if barrier_type == "–ü—Ä—è–º–æ–∫—É—Ç–Ω–∏–π –±–∞—Ä‚Äô—î—Ä":
            x = np.linspace(-2*L, 6*L, 1500)
            psi_r, prob, T, R = solver.solve_rectangular(E, U0, L, x)
        else:
            x = np.linspace(-5e-9, 5e-9, 1500)
            psi_r, prob, T, R = solver.solve_step(E, U0, x)

        st.metric("T (–ø—Ä–æ—Ö–æ–¥–∂–µ–Ω–Ω—è)", f"{T:.6e}")
        st.metric("R (–≤—ñ–¥–±–∏—Ç—Ç—è)", f"{R:.6f}")

        fig, ax = plt.subplots(figsize=(12, 6))
        ax.plot(x*1e9, np.zeros_like(x) + E/EV, 'r--', lw=2, label=f"E = {E_ev:.1f} –µ–í")
        ax.plot(x*1e9, psi_r*50 + E/EV, 'cyan', lw=2, label="Re œà(x)")
        ax.plot(x*1e9, prob*100 + E/EV, 'lime', lw=2, ls=':', alpha=0.8, label="|œà|¬≤")
        ax.set_xlabel("x (–Ω–º)")
        ax.set_title(barrier_type)
        ax.legend()
        st.pyplot(fig)

if __name__ == "__main__":
    run_barrier_sim()